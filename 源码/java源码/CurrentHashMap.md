## CurrentHashMap

#### 介绍

- 线程安全
- 比hashtable锁粒度更小

#### 常量&& 变量

```
数组长度为1<<30,前面两位表示32位的hash
初始化容量为2的整数倍，默认为16
数组的大小
并发级别是16，但是是之前的版本
复制因子0.75，超过它就进行扩容
链表转换为红黑树为8

```



#### put方法

```java
put(k,v){
    直接调用putVal
}
putVal(k,v,boolean){
    //当key和value是null的时候就抛出空指针异常
    //获取二次hash
    //操作次数
    //死循环，知道插入成功
    	//是否初始化
}
```





### 扩展

- hashTable

  底层数组+链表实现，无论是key还是value都不为bull，线程安全，实现安全的策略是将整个表锁住，初始化容量为11，扩容为x2+1;

- HashMap

  底层通过数组+链表，可以存储null键和null值，线程不安全

  初始化大小为16，扩容为2倍，大小为2的幂次

  每次扩容都会重新的计算存放的位置

  插入元素后才会判断该不该扩容，

  实体超过0.75的实体个数时进行扩容，重新计算hash，将数据放的更加的散。

  - hashMap初始化需要考虑的问题
    - hash冲突：如果在同一个map上，那么就生成一个实体链，执行的时候会遍历执行equal方法、
    - 加载因子：为了降低哈希冲突，所以0.75的时候就进行一次扩容
    - 为了加快key查找时间，还可以加大初始化大小。

### 总结

hashMap和HashTable都是使用hash计算来决定元素存储的，容量的大小表示了桶的大小，size记录当前的个数，负载因子。

hash表有一个负载极限，就是一个0~1之间的值，表示最大填满程度，达到极限的时候就会成倍的扩容，hashtable(x2+1)，hashMap(x2).扩容的时候会重新计算一个hash值，所以hash的容量越大就越会提高查询效率，但是会浪费内存。

- ConcurrentHashMap

  底层实现采样分段数组+链表，线层安全

  将map分为若干个槽，可以提供相同的线程安全，可以提升若干倍，默认是16倍，他和hashTable的不同就是一个只能单个并发，但是另一个可以多个一起进行，提供效率。

  但是在跨端操作时就需要锁住整个表，等到结束了，在将其释放

  段内扩容



hashMap可以存储为null的键值对，那么我们获取数据的时候，如果为null，那么就会有两种情况， 一种是值为null，一种是没有参数，所以hashMap中如果想知道释放有某个参数，那么就需要使用containsKey



























