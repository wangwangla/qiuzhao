[TOC]



## LibGdx源码分析

AndroidApplication
安卓应用启动继承这个class类，通过此类就可以创建一个活动，这个方法调用initialize进行初始化，然后系统会自动调用绘制方法进行绘制。



#### Android Input

libGdx使用input来实现用户输入事件的处理，用来接收用户输入。包括触摸、键盘等。

#####  1.初始化Input

- 应用程序启动时候，初始化动作执行。
```java
public void initialize (ApplicationListener listener, AndroidApplicationConfiguration config) {
	init(listener, config, false);
}
```
在这个方法中，通过如下方法将input获取到，然后赋值给Gdx.input。
- 通过AndroidInputFactory方法获取实例
  传入的参数是当前实例，在后面看是作为Activity和Context使用的。
```java
input = AndroidInputFactory.newAndroidInput(this, this, graphics.view, config);
```
方法实现也是比较简单的，通过反射的方式实现获取到一个AndroidInput实例返回
```java
public static AndroidInput newAndroidInput (Application activity, Context context, Object view,AndroidApplicationConfiguration config) {
	try {
		Class<?> clazz = null;
		AndroidInput input = null;
		int sdkVersion = android.os.Build.VERSION.SDK_INT;
		if (sdkVersion >= 12) {
			clazz = Class.forName("com.badlogic.gdx.backends.android.AndroidInputThreePlus");
		} else {
			clazz = Class.forName("com.badlogic.gdx.backends.android.AndroidInput");
		}
		Constructor<?> constructor = clazz.getConstructor(Application.class, Context.class, Object.class,
			AndroidApplicationConfiguration.class);
		input = (AndroidInput)constructor.newInstance(activity, context, view, config);
		return input;
	} catch (Exception e) {
		throw new RuntimeException("Couldn't construct AndroidInput, this should never happen", e);
	}
}
```
- AndroidInput的构造方法
  如果graphics创建是成功的，那么就给它设置监听事件，检测是否支持多建的操作，初始化函数里面主要是对事件的监听的注册
   这里我就开始懵逼了，那么有操作，怎样来获取事件呢，其实可以看一下，他复写了父类的方法。
```java
public AndroidInput (Application activity, Context context, Object view, AndroidApplicationConfiguration config) {
	// we hook into View, for LWPs we call onTouch below directly from
	// within the AndroidLivewallpaperEngine#onTouchEvent() method.
	if (view instanceof View) {
		View v = (View)view;
		v.setOnKeyListener(this);
		v.setOnTouchListener(this);
		v.setFocusable(true);
		v.setFocusableInTouchMode(true);
		v.requestFocus();
	}
	this.config = config;
	this.onscreenKeyboard = new AndroidOnscreenKeyboard(context, new Handler(), this);

	for (int i = 0; i < realId.length; i++)
		realId[i] = -1;
	handle = new Handler();
	this.app = activity;
	this.context = context;
	this.sleepTime = config.touchSleepTime;
	touchHandler = new AndroidMultiTouchHandler();
	hasMultitouch = touchHandler.supportsMultitouch(context);

	vibrator = (Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);

	int rotation = getRotation();
	DisplayMode mode = app.getGraphics().getDisplayMode();
	if (((rotation == 0 || rotation == 180) && (mode.width >= mode.height))
		|| ((rotation == 90 || rotation == 270) && (mode.width <= mode.height))) {
		nativeOrientation = Orientation.Landscape;
	} else {
		nativeOrientation = Orientation.Portrait;
	}

	// this is for backward compatibility: libGDX always caught the circle button, original comment:
	// circle button on Xperia Play shouldn't need catchBack == true
	keysToCatch.add(Keys.BUTTON_CIRCLE);
}
```
-  比如onTouch方法
```java
@Override
public boolean onTouch (View view, MotionEvent event) {
	if (requestFocus && view != null) {
		view.setFocusableInTouchMode(true);
		view.requestFocus();
		requestFocus = false;
	}

	// synchronized in handler.postTouchEvent()
	touchHandler.onTouch(event, this);

	if (sleepTime != 0) {
		try {
			Thread.sleep(sleepTime);
		} catch (InterruptedException e) {
		}
	}
	return true;
}
```

这个里面有这么一句
```java
touchHandler.onTouch(event, this);
```
它是将按下的事件和AndroidInput传入，将信息封装到AndroidInput中。
```java
public void onTouch (MotionEvent event, AndroidInput input) {
	final int action = event.getAction() & MotionEvent.ACTION_MASK;
	int pointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
	int pointerId = event.getPointerId(pointerIndex);

	int x = 0, y = 0;
	int realPointerIndex = 0;
	int button = Buttons.LEFT;

	long timeStamp = System.nanoTime();
	synchronized (input) {
		switch (action) {
		case MotionEvent.ACTION_DOWN:
		case MotionEvent.ACTION_POINTER_DOWN:
			realPointerIndex = input.getFreePointerIndex(); // get a free pointer index as reported by Input.getX() etc.
			if (realPointerIndex >= AndroidInput.NUM_TOUCHES) break;
			input.realId[realPointerIndex] = pointerId;
			x = (int)event.getX(pointerIndex);
			y = (int)event.getY(pointerIndex);
			if (android.os.Build.VERSION.SDK_INT >= 14) button = toGdxButton(event.getButtonState());
			if (button != -1) postTouchEvent(input, TouchEvent.TOUCH_DOWN, x, y, realPointerIndex, button, timeStamp);
			input.touchX[realPointerIndex] = x;
			input.touchY[realPointerIndex] = y;
			input.deltaX[realPointerIndex] = 0;
			input.deltaY[realPointerIndex] = 0;
			input.touched[realPointerIndex] = (button != -1);
			input.button[realPointerIndex] = button;
			input.pressure[realPointerIndex] = event.getPressure(pointerIndex);
			break;

		case MotionEvent.ACTION_UP:
		case MotionEvent.ACTION_POINTER_UP:
		case MotionEvent.ACTION_OUTSIDE:
			realPointerIndex = input.lookUpPointerIndex(pointerId);
			if (realPointerIndex == -1) break;
			if (realPointerIndex >= AndroidInput.NUM_TOUCHES) break;
			input.realId[realPointerIndex] = -1;
			x = (int)event.getX(pointerIndex);
			y = (int)event.getY(pointerIndex);
			button = input.button[realPointerIndex];
			if (button != -1) postTouchEvent(input, TouchEvent.TOUCH_UP, x, y, realPointerIndex, button, timeStamp);
			input.touchX[realPointerIndex] = x;
			input.touchY[realPointerIndex] = y;
			input.deltaX[realPointerIndex] = 0;
			input.deltaY[realPointerIndex] = 0;
			input.touched[realPointerIndex] = false;
			input.button[realPointerIndex] = 0;
			input.pressure[realPointerIndex] = 0;
			break;

		case MotionEvent.ACTION_CANCEL:
			for (int i = 0; i < input.realId.length; i++) {
				input.realId[i] = -1;
				input.touchX[i] = 0;
				input.touchY[i] = 0;
				input.deltaX[i] = 0;
				input.deltaY[i] = 0;
				input.touched[i] = false;
				input.button[i] = 0;
				input.pressure[i] = 0;
			}
			break;

		case MotionEvent.ACTION_MOVE:
			int pointerCount = event.getPointerCount();
			for (int i = 0; i < pointerCount; i++) {
				pointerIndex = i;
				pointerId = event.getPointerId(pointerIndex);
				x = (int)event.getX(pointerIndex);
				y = (int)event.getY(pointerIndex);
				realPointerIndex = input.lookUpPointerIndex(pointerId);
				if (realPointerIndex == -1) continue;
				if (realPointerIndex >= AndroidInput.NUM_TOUCHES) break;
				button = input.button[realPointerIndex];
				if (button != -1)
					postTouchEvent(input, TouchEvent.TOUCH_DRAGGED, x, y, realPointerIndex, button, timeStamp);
				else
					postTouchEvent(input, TouchEvent.TOUCH_MOVED, x, y, realPointerIndex, 0, timeStamp);
				input.deltaX[realPointerIndex] = x - input.touchX[realPointerIndex];
				input.deltaY[realPointerIndex] = y - input.touchY[realPointerIndex];
				input.touchX[realPointerIndex] = x;
				input.touchY[realPointerIndex] = y;
				input.pressure[realPointerIndex] = event.getPressure(pointerIndex);
			}
			break;
		}
	}
	Gdx.app.getGraphics().requestRendering();
}

private void logAction (int action, int pointer) {
	String actionStr = "";
	if (action == MotionEvent.ACTION_DOWN)
		actionStr = "DOWN";
	else if (action == MotionEvent.ACTION_POINTER_DOWN)
		actionStr = "POINTER DOWN";
	else if (action == MotionEvent.ACTION_UP)
		actionStr = "UP";
	else if (action == MotionEvent.ACTION_POINTER_UP)
		actionStr = "POINTER UP";
	else if (action == MotionEvent.ACTION_OUTSIDE)
		actionStr = "OUTSIDE";
	else if (action == MotionEvent.ACTION_CANCEL)
		actionStr = "CANCEL";
	else if (action == MotionEvent.ACTION_MOVE)
		actionStr = "MOVE";
	else
		actionStr = "UNKNOWN (" + action + ")";
	Gdx.app.log("AndroidMultiTouchHandler", "action " + actionStr + ", Android pointer id: " + pointer);
}

private int toGdxButton (int button) {
	if (button == 0 || button == 1) return Buttons.LEFT;
	if (button == 2) return Buttons.RIGHT;
	if (button == 4) return Buttons.MIDDLE;
	if (button == 8) return Buttons.BACK;
	if (button == 16) return Buttons.FORWARD;
	return -1;
}

private void postTouchEvent (AndroidInput input, int type, int x, int y, int pointer, int button, long timeStamp) {
	TouchEvent event = input.usedTouchEvents.obtain();
	event.timeStamp = timeStamp;
	event.pointer = pointer;
	event.x = x;
	event.y = y;
	event.type = type;
	event.button = button;
	input.touchEvents.add(event);
}

public boolean supportsMultitouch (Context activity) {
	return activity.getPackageManager().hasSystemFeature("android.hardware.touchscreen.multitouch");
}
}
```


通过以上代码就可以获取到Input，但是在使用的过程中，还需要下面的方法

```java
public void setInputProcessor (InputProcessor processor) {
    synchronized (this) {
        this.processor = processor;
    }
}
```

	/** Sets the {@link InputProcessor} that will receive all touch and key input events. It will be called before the
	 * {@link ApplicationListener#render()} method each frame.
	 * 
	 * @param processor the InputProcessor */
	public void setInputProcessor (InputProcessor processor);







### AndroidAudio
- 他是实现了android的Audio接口。
- 构造函数
  - 通过创建SoundPool来实现的，调用安卓的AudioManager服务
```java
public AndroidAudio (Context context, AndroidApplicationConfiguration config) {
if (!config.disableAudio) {
soundPool = new SoundPool(config.maxSimultaneousSounds, AudioManager.STREAM_MUSIC, 100);
manager = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
if (context instanceof Activity) {
((Activity)context).setVolumeControlStream(AudioManager.STREAM_MUSIC);
```
- dispose
  将数组中的music都执行dispose方法，使用锁的方式一个一个的执行
```java
public void dispose () {
	if (soundPool == null) {
		return;
	}
	synchronized (musics) {
		// gah i hate myself.... music.dispose() removes the music from the list...
		ArrayList<AndroidMusic> musicsCopy = new ArrayList<AndroidMusic>(musics);
		for (AndroidMusic music : musicsCopy) {
			music.dispose();
		}
	}
	soundPool.release();
}
```
- pause
  当执行声明之前pause方法的时候，如果是正在播放，那么就将状态设置为true，如不是那就是false。
```java
protected void pause () {
	if (soundPool == null) {
		return;
	}
	synchronized (musics) {
		for (AndroidMusic music : musics) {
			if (music.isPlaying()) {
				music.pause();
				music.wasPlaying = true;					
			} else
				music.wasPlaying = false;
		}
	}
	this.soundPool.autoPause();
}
```
- 增加music
  - 首先判断文件是从哪里来的
  - 创建MediaPlayer
  - 将MediaPlayer放入到集合中。
  ```java
  MediaPlayer mediaPlayer = new MediaPlayer();
  mediaPlayer.setDataSource(descriptor.getFileDescriptor(), descriptor.getStartOffset(), descriptor.getLength());
  mediaPlayer.prepare();
  AndroidMusic music = new AndroidMusic(this, mediaPlayer);
  synchronized (musics) {
  	musics.add(music);
  }
  
  ```
```java
/** {@inheritDoc} */
	@Override
	public Music newMusic (FileHandle file) {
		if (soundPool == null) {
			throw new GdxRuntimeException("Android audio is not enabled by the application config.");
		}
		AndroidFileHandle aHandle = (AndroidFileHandle)file;

		MediaPlayer mediaPlayer = new MediaPlayer();

		if (aHandle.type() == FileType.Internal) {
			try {
				AssetFileDescriptor descriptor = aHandle.assets.openFd(aHandle.path());
				mediaPlayer.setDataSource(descriptor.getFileDescriptor(), descriptor.getStartOffset(), descriptor.getLength());
				descriptor.close();
				mediaPlayer.prepare();
				AndroidMusic music = new AndroidMusic(this, mediaPlayer);
				synchronized (musics) {
					musics.add(music);
				}
				return music;
			} catch (Exception ex) {
				throw new GdxRuntimeException("Error loading audio file: " + file
					+ "\nNote: Internal audio files must be placed in the assets directory.", ex);
			}
		} else {
			try {
				mediaPlayer.setDataSource(aHandle.file().getPath());
				mediaPlayer.prepare();
				AndroidMusic music = new AndroidMusic(this, mediaPlayer);
				synchronized (musics) {
					musics.add(music);
				}
				return music;
			} catch (Exception ex) {
				throw new GdxRuntimeException("Error loading audio file: " + file, ex);
			}
		}

	}

```
- 




public final class AndroidAudio implements Audio {
	private final SoundPool soundPool;
	private final AudioManager manager;
	protected final List<AndroidMusic> musics = new ArrayList<AndroidMusic>();


	protected void pause () {
		if (soundPool == null) {
			return;
		}
		synchronized (musics) {
			for (AndroidMusic music : musics) {
				if (music.isPlaying()) {
					music.pause();
					music.wasPlaying = true;					
				} else
					music.wasPlaying = false;
			}
		}
		this.soundPool.autoPause();
	}
	
	protected void resume () {
		if (soundPool == null) {
			return;
		}
		synchronized (musics) {
			for (int i = 0; i < musics.size(); i++) {
				if (musics.get(i).wasPlaying == true) musics.get(i).play();
			}
		}
		this.soundPool.autoResume();
	}
	
	/** {@inheritDoc} */
	@Override
	public AudioDevice newAudioDevice (int samplingRate, boolean isMono) {
		if (soundPool == null) {
			throw new GdxRuntimeException("Android audio is not enabled by the application config.");
		}
		return new AndroidAudioDevice(samplingRate, isMono);
	}
	
	/** {@inheritDoc} */
	@Override
	public Music newMusic (FileHandle file) {
		if (soundPool == null) {
			throw new GdxRuntimeException("Android audio is not enabled by the application config.");
		}
		AndroidFileHandle aHandle = (AndroidFileHandle)file;
	
		MediaPlayer mediaPlayer = new MediaPlayer();
	
		if (aHandle.type() == FileType.Internal) {
			try {
				AssetFileDescriptor descriptor = aHandle.assets.openFd(aHandle.path());
				mediaPlayer.setDataSource(descriptor.getFileDescriptor(), descriptor.getStartOffset(), descriptor.getLength());
				descriptor.close();
				mediaPlayer.prepare();
				AndroidMusic music = new AndroidMusic(this, mediaPlayer);
				synchronized (musics) {
					musics.add(music);
				}
				return music;
			} catch (Exception ex) {
				throw new GdxRuntimeException("Error loading audio file: " + file
					+ "\nNote: Internal audio files must be placed in the assets directory.", ex);
			}
		} else {
			try {
				mediaPlayer.setDataSource(aHandle.file().getPath());
				mediaPlayer.prepare();
				AndroidMusic music = new AndroidMusic(this, mediaPlayer);
				synchronized (musics) {
					musics.add(music);
				}
				return music;
			} catch (Exception ex) {
				throw new GdxRuntimeException("Error loading audio file: " + file, ex);
			}
		}
	
	}
	
	/** {@inheritDoc} */
	@Override
	public Sound newSound (FileHandle file) {
		if (soundPool == null) {
			throw new GdxRuntimeException("Android audio is not enabled by the application config.");
		}
		AndroidFileHandle aHandle = (AndroidFileHandle)file;
		if (aHandle.type() == FileType.Internal) {
			try {
				AssetFileDescriptor descriptor = aHandle.assets.openFd(aHandle.path());
				AndroidSound sound = new AndroidSound(soundPool, manager, soundPool.load(descriptor, 1));
				descriptor.close();
				return sound;
			} catch (IOException ex) {
				throw new GdxRuntimeException("Error loading audio file: " + file
					+ "\nNote: Internal audio files must be placed in the assets directory.", ex);
			}
		} else {
			try {
				return new AndroidSound(soundPool, manager, soundPool.load(aHandle.file().getPath(), 1));
			} catch (Exception ex) {
				throw new GdxRuntimeException("Error loading audio file: " + file, ex);
			}
		}
	}
	
	/** {@inheritDoc} */
	@Override
	public AudioRecorder newAudioRecorder (int samplingRate, boolean isMono) {
		if (soundPool == null) {
			throw new GdxRuntimeException("Android audio is not enabled by the application config.");
		}
		return new AndroidAudioRecorder(samplingRate, isMono);
	}
	
	/** Kills the soundpool and all other resources */
	public void dispose () {
		if (soundPool == null) {
			return;
		}
		synchronized (musics) {
			// gah i hate myself.... music.dispose() removes the music from the list...
			ArrayList<AndroidMusic> musicsCopy = new ArrayList<AndroidMusic>(musics);
			for (AndroidMusic music : musicsCopy) {
				music.dispose();
			}
		}
		soundPool.release();
	}
}



## net


```java
@Override
public boolean openURI (String URI) {
	boolean result = false;
	final Uri uri = Uri.parse(URI);
	Intent intent = new Intent(Intent.ACTION_VIEW, uri);
	PackageManager pm = app.getContext().getPackageManager();
	//这句是匹配一个活动，如果匹配成功就执行，否则就返回一个false
	if (pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) {
		app.runOnUiThread(new Runnable() {
			@Override
			public void run () {
				Intent intent = new Intent(Intent.ACTION_VIEW, uri);
				// LiveWallpaper and Daydream applications need this flag
				if (!(app.getContext() instanceof Activity))
					intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
				app.startActivity(intent);
			}
		});
		result = true;
	}
	return result;
}
```

## 网络返回一个byte
最原始的网络请求
- **创建一个URL**
- **获取连接**
- 设置请求方式
- 设置超时时间
- 读取的最大时间
- **读取流**
- **写入reader**
- **将结果返回**
```java
HttpURLConnection connection = null;
BufferedReader reader = null;
try{

	URL url = new URL("https://www.baidu.com");//新建URL
	connection = (HttpURLConnection)url.openConnection();//发起网络请求
	connection.setRequestMethod("GET");//请求方式
	connection.setConnectTimeout(8000);//连接最大时间
	connection.setReadTimeout(8000);//读取最大时间
	InputStream in = connection.getInputStream();
	reader = new BufferedReader(new InputStreamReader(in));//写入reader
	StringBuilder response = new StringBuilder();
	String line;
	while((line = reader.readLine()) != null){
		response.append(line);
	}
	showResponse(response.toString());//更新ui
```

- 安卓网络请求方式，在创建的时候，根据默认配置创建一个最大线程数，通过池创建
```java
public NetJavaImpl (int maxThreads) {
	executorService = new ThreadPoolExecutor(0, maxThreads,
			60L, TimeUnit.SECONDS,
			new SynchronousQueue<Runnable>(),
			new ThreadFactory() {
				@Override
				public Thread newThread(Runnable r) {
					Thread thread = new Thread(r, "NetThread");
					thread.setDaemon(true);
					return thread;
				}
			});
	connections = new ObjectMap<HttpRequest, HttpURLConnection>();
	listeners = new ObjectMap<HttpRequest, HttpResponseListener>();
}
```
- 创建连接
  - 判断URL是否为null.
  - 获取请求方法
  - 如果是get就拼接URL,否则就只设置url.
  - 获取连接
  - 对连接进行设置，包括方法和头
  - 设置监听，如果取消，那么就取消监听
  - 然后提交请求

  
```java
public void sendHttpRequest (final HttpRequest httpRequest, final HttpResponseListener httpResponseListener) {
		final HttpURLConnection connection = (HttpURLConnection)url.openConnection();
		// should be enabled to upload data.
		final boolean doingOutPut = method.equalsIgnoreCase(HttpMethods.POST) || method.equalsIgnoreCase(HttpMethods.PUT) || method.equalsIgnoreCase(HttpMethods.PATCH);
		connection.setDoOutput(doingOutPut);
		connection.setDoInput(true);
		connection.setRequestMethod(method);
		HttpURLConnection.setFollowRedirects(httpRequest.getFollowRedirects());

		putIntoConnectionsAndListeners(httpRequest, httpResponseListener, connection);

		// Headers get set regardless of the method
		for (Map.Entry<String, String> header : httpRequest.getHeaders().entrySet())
			connection.addRequestProperty(header.getKey(), header.getValue());

		// Set Timeouts
		connection.setConnectTimeout(httpRequest.getTimeOut());
		connection.setReadTimeout(httpRequest.getTimeOut());

		executorService.submit(new Runnable() {
			@Override
			public void run() {
				try {
					// Set the content for POST and PUT (GET has the information embedded in the URL)
					if (doingOutPut) {
						// we probably need to use the content as stream here instead of using it as a string.
						String contentAsString = httpRequest.getContent();
						if (contentAsString != null) {
							OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream(), "UTF8");
							try {
								writer.write(contentAsString);
							} finally {
								StreamUtils.closeQuietly(writer);
							}
						} else {
							InputStream contentAsStream = httpRequest.getContentStream();
							if (contentAsStream != null) {
								OutputStream os = connection.getOutputStream();
								try {
									StreamUtils.copyStream(contentAsStream, os);
								} finally {
									StreamUtils.closeQuietly(os);
								}
							}
						}
					}

					connection.connect();

					final HttpClientResponse clientResponse = new HttpClientResponse(connection);
					try {
						HttpResponseListener listener = getFromListeners(httpRequest);

						if (listener != null) {
							listener.handleHttpResponse(clientResponse);
						}
						removeFromConnectionsAndListeners(httpRequest);
					} finally {
						connection.disconnect();
					}
				} catch (final Exception e) {
					connection.disconnect();
					try {
						httpResponseListener.failed(e);
					} finally {
						removeFromConnectionsAndListeners(httpRequest);
					}
				}
			}
		});
	} catch (Exception e) {
		try {
			httpResponseListener.failed(e);
		} finally {
			removeFromConnectionsAndListeners(httpRequest);
		}
		return;
	}
}

```

### 处理方式
得到输出流，输入流设置缓存区，将输出流返回，转化为数组的形式。

```jaba
private InputStream getInputStream () {
	try {
		return connection.getInputStream();
	} catch (IOException e) {
		return connection.getErrorStream();
	}
}
```

return StreamUtils.copyStreamToByteArray(input, connection.getContentLength());

```java
/** Copy the data from an {@link InputStream} to a byte array. The stream is not closed. */
public static byte[] copyStreamToByteArray (InputStream input) throws IOException {
	return copyStreamToByteArray(input, input.available());
}

	/** Copy the data from an {@link InputStream} to a byte array. The stream is not closed.
 * @param estimatedSize Used to allocate the output byte[] to possibly avoid an array copy. */
public static byte[] copyStreamToByteArray (InputStream input, int estimatedSize) throws IOException {
	ByteArrayOutputStream baos = new OptimizedByteArrayOutputStream(Math.max(0, estimatedSize));
	copyStream(input, baos);
	return baos.toByteArray();
}

//得到输出流，输入流设置缓存区，将输出流返回
public static int copyStream (InputStream input, ByteBuffer output, byte[] buffer) throws IOException {
	int startPosition = output.position(), total = 0, bytesRead;
	while ((bytesRead = input.read(buffer)) != -1) {
		BufferUtils.copy(buffer, 0, output, bytesRead);
		total += bytesRead;
		output.position(startPosition + total);
	}
	output.position(startPosition);
	return total;
}
```


## socket
- 是否连接
  public boolean isConnected ();
- 读取参数
  public InputStream getInputStream ();
- 返回一个流用于读写
  public OutputStream getOutputStream ();
- 返回地址
  public String getRemoteAddress ();

#### 实现
```java
// create the socket
socket = new java.net.Socket();
//对socket的惨呼进行设置
applyHints(hints); // better to call BEFORE socket is connected!
// and connect...
InetSocketAddress address = new InetSocketAddress(host, port);
if (hints != null) {
socket.connect(address, hints.connectTimeout);
else
socket.connect(address);
```
#### ServerSocket
```java
//创建server
server = new java.net.ServerSocket();
//设置参数
if (hints != null) {
server.setPerformancePreferences(hints.performancePrefConnectionTime, hints.performancePrefLatency,
hints.performancePrefBandwidth);
server.setReuseAddress(hints.reuseAddress);
server.setSoTimeout(hints.acceptTimeout);
server.setReceiveBufferSize(hints.receiveBufferSize);
}
//绑定地址
InetSocketAddress address;
if( hostname != null ) {
address = new InetSocketAddress(hostname, port); 
} else {
address = new InetSocketAddress(port);
}
if (hints != null) {
server.bind(address, hints.backlog);
} else {
server.bind(address);
}
//等待请求，堵塞的
@Override
public Socket accept (SocketHints hints) {
	try {
		return new NetJavaSocketImpl(server.accept(), hints);
	} catch (Exception e) {
		throw new GdxRuntimeException("Error accepting socket.", e);
	}
}
@Override
public void dispose () {
	if (server != null) {
		try {
			server.close();
			server = null;
		} catch (Exception e) {
			throw new GdxRuntimeException("Error closing server.", e);
	}
}
```
