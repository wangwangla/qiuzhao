1.线程的作用？
    发挥多内核的优势
        在单核上多线程是没有优势的，因为线程切换的时候，上下文也是需要切换的，反而降低了效率。有时候为了防止阻塞，还是会
        使用的【读取IO数据的是时候，需要等待返回】。
2.实现方式有三种：Runnable Thread  callable 
3.Runnable和Callable的区别：
    Runnable接口么有返回值，callable有返回值，可以判断线程是否执行了，是否执行结束。
4.CyclicBarrier和CountDownLatch的区别
    CyclicBarrier的某个线程到达某个点上就直接的停止，直到所有的点都到大之后才可以重新运行
    CountDownLatch在线程到达之后只是返回一个-1，线程继续执行

    CyclicBarrier只可以唤起一个线程，countDownLatch可以唤起多个线程

    CyclicBarrier可以重用
    countDownLatch不可以重用

5.volitile作用：

6.线程安全
    在多线程和单线程情况下，结果是一致的，那么线程就是安全的。


扩展：
    不可变   ：final修饰的类，变量就可以直接在多线程下使用
    绝对安全 ：不管运行环境如何，调用者无需提供任何的的同步措施
    相对安全 ：Vector
    线程非安全的

7.java中如何获取到线程dump文件
    对于循环


8.运行是异常：如果没有被捕获，这个时候，线程停止执行了
如果这个线程持有某个对象的监听器，这个监听器也会被立即释放


9.两个线程之间的共享
    通过线程之间共享对象就可以了，通过wait notify 进行唤起和等待

10.生产者和消费者
    通过消费者和生产者能力来提升系统的运行的效率

    解耦：生产者和消费者之间的关系越来越少。

11.wait和notify一定是在同步代码块内进行的，这个是必须的 。

12.wait和notify的区别
    都可以放弃对象监听器
    wait是立即释放监听器   notify是等待剩余代码执行完之后，才会进行放弃监听。

13.为什么使用连接池？
    为了节约连接池频繁的连接和释放对资源的消耗过大，达到线程重用的目的。

14，如何判断线程是否持有锁？
    Thread提供了一个holdLock方法，当且仅当对象持有锁的时候，才会返回true

15.ConcurrentHashMap的并发度是什么？
    并发度就是segment的大小，它的默认是16，也就是说默认可以有16条同时操作。

16.ReentrantLock是什么？
    他是一般的锁，也就是，读写互斥，读读互斥，写写也是互斥。改进的是ReadWriteLock就是至于同时写的时候是互斥的

17.同步代码块和同步方法有什么区别？
    首先在枷锁的时候有一个原则即使：锁定范围越小越好，因为同步之外的可以异步处理，但是也不是绝对的，以为
    因为频繁的加取锁会造成性能的问题，这个时候锁粗化比较好

18。线程类的构造方法和静态可快是谁调用的
    是new这个线程类所在的线程调用的，run方法是创建的这个线程调用的。

19.

























