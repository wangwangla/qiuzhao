## 走进并行

概念

- 同步：就是一次请求，调用者必须等到方法响应结束后在进行下一次请求
- 异步：一次请求，不需要响应结束，就可以发送下一次请求。异步一般会在另一个线程中真实的运行，整个过程，不会阻碍调用者
- 并发：一般是交替进行
- 并行：同时进行
- 临界区：共享变量、公共资源，每次只能有一个线程访问，其他的只能等待。
- 阻塞：多个线程在一个临界中，其他的只能等待，无法继续工作。
- 非阻塞：与堵塞相反
- 死锁：就是多个锁同时相互交织在一起。
- 活锁：主动的将资源给对方使用
- 饥饿锁：就是多个线程都无法获取到自己想要的资源，比如低优先级的一直无法获取到资源，高优先级将资源一直都保留在自己手中。

并发级别：

- 阻塞：一个线性处于阻塞的，那么在其他线程释放之前，当前线程无法执行，当使用synchronized关键字或者重入锁的时候，我们得到的就是阻塞的线程。

  Synchronized关键字和重入锁都在视图执行后面代码前，得不到就会挂起

- 无饥饿：如果线程之间是有优先级的，那么调度的时候总会倾向于优先级高的，分配时不公平的，公平锁就是在执行过程中获取是公平的，先后顺序。

- 无障碍：无障碍，就是临界区可以直接的通过，通过数据不一致就会立即回滚，确保数据安全，如果一致就会执行到结束。问题：一直不一致，一直无法退出。

- 无锁：**区别无锁和无障碍**

- 无等待

#### 有关并行的定律

- Amdahl定律
- Gustafson定律
- 是否矛盾

JMM

- 原子性：原子性，一旦任务开始，就会执行到结束，不会中途停止了。

  int多线程操作是原子的，但是long/double类型的时候，就不是原子的了，他会有所不同、（32位机器）。这个也类似于一个类多个属性的打印。

- 可见性：就是一个线程发生了改变，其他的线程就会立即的感知到发生的变化、

- 有序性

- 不可排序的指令

那些是可以重排的。

