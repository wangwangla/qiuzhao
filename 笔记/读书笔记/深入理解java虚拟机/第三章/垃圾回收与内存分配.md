## 目的
```

    当需要排查各种问题的时候、内存溢出、内存泄露时，当垃圾收集机制成为瓶颈时，需要对自动化进行异一定的监控。

```
## 回收哪里
```

    程序计数器、虚拟机栈、本地方法栈线程私有，线程没了，他自然没了，进栈出栈的东西在开始就已经确定了，确定性高。

    堆、方法区：不确定性高，不断的创建，垃圾进行回收。

```
## 回收哪里的谁，什么时候
```

    上帝：你要回收谁？

        魔鬼：回收死的，保留活的

    上帝：什么是死，什么是活？？

        魔鬼：被引用便是活，违被引用了便是死。

    上帝：什么样的是被引用了，什么样的是没有被引用？

        魔鬼：引用计数器   可达性判断
    
    上帝：什么时候回收我？？

        魔鬼：你与天地同在，~（感觉这就是跪舔）

==================================================
```  
### 引用计数器：
```

    给对象一个引用计数器，如果添加了一个引用，就将这个引用计数器加1，失去一个就将其减去1，如果计数器为0，那么就没被引用了。
    存在的问题就是引用链

```
### 可达性分析
```

    就是从GC Roots开始向下找，速索所走的路径，如果不可达，那么就没有被引用。

    引入和前面的两种引用方式，但是对于鸡肋来说，也就显得无能为力，那么鸡肋也是有其特有的引用方式，如果内存足够就留着，不够就采取果断措施。

```
### 引用
```

    引用分为:强引用、软引用、弱引用、虚引用，这四种的引用是逐渐减弱。

    强引用：
        一般就是new出来的，这样的存在就不会被清除，这个也是普遍存在的。
    软引用：
        这个就是鸡肋了，如果内存不够，那就进行回收，如果这次的回收，内存依旧不够使用的时候，就会发生第二次回收。
    弱引用:
        这个只可以活到下次回收之前，下一次垃圾回收就一定会被回收掉。和内存是没有关系的。
    虚引用：
        不会为生存时间造成影响，也无法通过它获得一个实例。
        我要这铁棒有何用~
        这个对象呗收集器回收时的一个系统通知
    
```
### 生存还是死亡（生死存亡之秋）
```

    生死存亡之秋：只能说很危险，不能说就死了呀。

    对于不可达的对象也就到达了这个地方，要真的死需要两次。
    第一次：帅选的条件是：是否有必要执行finalize()

    上帝：什么是有必要

        魔鬼：没有覆盖这个方法，或者说已经被调用过，就会被视为“没有必要执行”

    如果有必要执行finalize方法，那么这个对象就会防在一个队列中，并稍后有一个虚拟机自动建立，并有一个线程优先级低的线程去执行它【他是不保证等待他执行成功的，因为如果这个方法执行缓慢，可能会导致等待，导致整个回收系统无法使用】

    稍后GC在来执行标记
        如果链上了，就溢出即将回收集合
        未链上，就会被回收

    谁可以作为链使用呢？
        虚拟机栈中的引用的对象
        方法区中静态属性引用对象
        方法区中的常量引用对象
        本地方法中的引用对象
    

    案例：
    SAVE_HOOK = new FinalizeEscapeGC();

		//对象第一次成功拯救自己
		SAVE_HOOK = null;
		System.gc();
		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
		Thread.sleep(500);
		if (SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("no, i am dead :(");
		}

		// 下面这段代码与上面的完全相同，但是这次自救却失败了
		SAVE_HOOK = null;
		System.gc();
		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
		Thread.sleep(500);
		if (SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("no, i am dead :(");
		}
        上面有两段代码是一样的，但是打印的结果是不一样的
        第一次是活的，第二次是死的。

        finalize()这个方法可以救他们，但是只是可以被执行一次。

    补充：finalize()具有不确定性，执行也是不确定的，虽然可以关闭资源，但是也不是很推荐。
    关闭资源可以使用try finally

```
### 回收方法区
```

    java虚拟机在方法区中不要求实现垃圾回收的，而且在方法区中进行垃圾回收的“性价比”一般比较低，而且回收效率也低。

    回顾：永久带存什么？
        常量、类

    回收：废弃的常量和无用的类
        在永久带中，未被引用的常量就会被回收。
        常量池：类的接口、方法、字段的符号引用
    
    判断类无用：
        堆中不存在它的任何实例的时候，实例已经都被回收
        类加载器被回收
        在该类对应的java.lang.Class对象没有在其他地方呗引用,无法在任何地方通过反射创建该类的方法。

    满足上面的仅仅可以被回收，是否被回收，还和参数这种有关。


回收谁也知道了，什么样的回收也知道了

```
# 怎么回收
```

    垃圾回收的思想：
    标记-清除算法：
        标记和清除：所以会出现两个操作，两个操作会造成效率的问题，第二个收集之后会造成碎片化问题。无法满足连续的内存分配
    复制算法：
        每次将内存分为两半，每次之用一般， 需要回收的时候，将存活的放在一边，将另一边直接清除掉，然后再将存活的复制回来。
        
        优点：解决了空间的碎片化  节约空间，我呸，每次只用一般。
            解决了效率【原因稍等在说】
        缺点：浪费资源

        分析：眨眼一看，复制肯定慢呀，不过这个是用在新生代的，新生代怎么了，新生代存活的少，大部分都被清理了，所以复制的也是恨少的。
    
    内存担保：就是将大对象直接放入到老年代里面
        【surivor==》old】
    
    复制太多效率变低，那么标记整理，又如何呢
    标记整理:
        复制效率太低  浪费一半内存
        如果百分之百存活的对象，那么就让他进入老年代，也就是担保

        本方法是将存放的向一个方向移动，然后清除掉边界之外的。
    
    分代收集机制
        这个就是将堆分为多块，新生代老年代，根据不同的年龄段，根据不同的回收方式。
        年轻代一次回收的多，使用的是复制的方法
        老年代使得是标记清除或者标记整理

```
# Hotspot 算法实现
```


```
### 枚举根节点
```

    以可达性GC roots为例
    （1）由于可达性是通过GC roots节点找引用链，但是主节点的全局引用于上下文中的数据量是很大的，逐个进行检查，是很耗费时间的。
    （2）在执行gc的时候，需要保证数据的一致性，也就是在执行 的时候，数据必须都是一样的，不可以在这一时刻处于修改状态，为了数据一致性，那么就需要将其停止下来，否则数据的准确性是无法得到满足的。
    （3）系统停止下来之后，并不需要一点一点的去查找对象的位置，虚拟机直接有办法得到哪些地方存储这个引用。
    在本虚拟机中使用OopMap的数据结构来实现这个目的的，在编译的时候，也会特意的将栈和寄存器中的哪些位置是引用，这样GC就可以直接知道信息了。

```
### 安全点
```
    问题：OoPMap使用的时候，OopMap中的数据量会有很多，那么这些数据量又会增加GC的成本
    实际上并不是,他是通过在特定的位置记录这些信息，这些特定的 位置，也就是安全点。
    也就是说并不是在任何地方都停下来执行GC的，只有在到达安全点的时候执行。

    安全点不可以太少，太少垃圾太多，那么每次使用 的时间就会太多，安全点的选择是以程序“是否具有长时间执行的特征”，每条指令执行的时间都是非常短暂的，程序不太可能出现长时间运行的状态

    长时间一般就是方法调用、循环跳转、异常跳转等，这些功能的指令才会产生安全点。

    上面的那些地方可以作为安全点，那么怎样才可以让他们到达最近的安全点停止下来，目前有两种方式
        抢先式：就是在要发生GC的时候，让所有线程停下来，然后未到达安全点的在让其运行，跑到安全点上。
        主动中段：不让线程直接停止下来，而是设置一个标准，所有线程到了这里都停止下来，然后自己在这里轮询，发现标志为就让自己在这里挂起。

```
### 安全区域
```

    安全区域：刚才也说了，当执行到安全点，那模我没有CPU,我就不会动（运行），我如何去到达安全点，所以就来了安全区域。
    安全区域就是在一段代码之中，引用关系并不会发生变化，但是问题又来了，虽然我来到了安全区域，那什么时候离开呢？离开之前我需干什么?jVM发起GC,当要离开的时候，就会去判断GC是否执行完毕，如果完毕了，那么就可以继续的进行执行，如果么有执行结束，那么就只有等到可以离开的信号位置。


```
### 垃圾的收集器
```

    具体的实现垃圾回收。
    （1）Serial收集器
        Serial收集器是最基本的、历史最悠久的，他是单线程收集器，一个CPU一个线程收集器去完成工作，在进行垃圾回收的时候，必须将其他线程停止下来，知道垃圾回收结束，这都是在后台由虚拟机来完成的。

        他可以运用在客户端条件下，简单高效，对于多线程来说，没有线程之间的切换与交互，在用户的桌面中使用还是比较多的。
    （2）ParNew
        是serial的多线程版本，

```
### 内存分配和回收策略
```

    java的自动化解决了两个问题：
        对象分配内存以及回收分配的内存
        内存分配就是在堆上分配空间，对象主要分配在新生代上，如果启动了本地线程分配缓冲，那么就会在TLAB上分配。少数的也会直接去老年代上，这个和参数和垃圾回收机制是有关的。

    最基本的规则
        对象优先分配在Eden上，如果空间不足的时候发起一次Minor GC
        大对象直接进入到了老年代，因为在年轻代使用的是复制算法处理的，为了较少多次的执行复制，这个可以有个参数设置，如果大于这个参数就会将其直接放入到老年代中。
        
        大的对象包括：非常大的数组、对象
        长期存货的直接进入到老年代，如果在第一次发生Minor GC之后还存货的就会进入到survivor，年龄也会加1，每执行一次就会增加1，当年领到达15的是就会直接进入老年代

        有时候并不是严格按照年龄来做的，有时候虚拟机Survivor中的年龄所以对象大小总和大于Survivor空间的一般的时候，就会将这个年龄和大于这个年龄的进入到老年代中。


