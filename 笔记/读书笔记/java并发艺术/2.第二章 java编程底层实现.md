# 底层实现
```
    java语言编译之后生成字节码文件，字节码文件被虚拟机获取转换为汇编语言被机器执行。底层实现依赖于jvm的实现和cpu指令。
```
## volatile实现
```
    多线程的两个关键字volatile和synchronized，volatile比synchronized轻量级，可以实现共享变量的可见性，其他线程可以立刻感知到数据的变化，不会引起上下文的切换。

```
### volatile实现原理
```
    当执行的时候会对volatile进行写操作为例
    volatile修饰的会出现lock修饰的代码

    lock会有什么作用：
        将当前的处理器缓存行的数据写回到系统内容
        其他cpu里的数据无效。
        如果设置了lock，设置lock之后，就会将它写入到系统内存，但是系统内存中其他工作内存仍然是就的，这个时候就会通过每个处理器嗅探总线上的数据来检查自己是否已经过期，过期将会标记，当使用的是就会重新的获取这个值。
    
    内存模型
        工作内存 系统内存 
        操作的时候将系统内存的数据放入到工作内存，在工作内存进行操作，并不会写入到系统内存，这也是会发生数据不一致的原因

    volatile的原则
        lock前缀会引起处理器缓存写到内存中
        一个处理器缓存中的数据无效


```
### synchronized的实现原理
```
    它可以使用的地方
    使用普通同步方法
    静态同步方法
    同步方法

    在执行的时候，如果出现异常，那么就会将锁释放。
    在JVM里的实现是通过监听来完成的，Moniter进入和退出来实现同步和代码块，如果是代码块那么就是moniterenter好人monitorexit实现的，但是同步方法并没有说明

    monitorenter和monitorexit编译后会插入到代码开始和结束的地方或者异常出
    每一个对象都有一个monitor，当monitor被持有后就会处于锁定状态，执行到monitorenter就会尝试去获取monitor的执行权。
    
```
### 锁的升级
```
    为了减少获得锁和释放锁的性能消耗，引入了偏向锁和轻量级锁，在java中锁一个有四种：无锁、偏向锁、轻量级锁，重量级锁可以随着竞争而不断的升级，但是锁是不可以降级的，目的是为了获得锁和释放锁的效率

    偏向锁：
        大多情况下，锁不仅存在多线程的竞争，而是总是由统一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

        当一个线程访问同步块并获得锁时，会在对象头和栈中的记录里存储偏向锁的线程ID，以后该线程在进入和退出的时候不需要进行CAS操作来加锁和解锁，只需要简单的测试一下对象头里面是否存储着指向当前线程的偏向锁。
        如果测试成功，表示线程已经获得了偏向锁，如果测试失败了，那就在此的测试设置标识是否为1，如果没有，那就使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。


    轻量级锁



```
### 原子操作的基本原理
```