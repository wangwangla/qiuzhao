# 第六章 进入三维

- 二维可以视为三维使用的技巧就是使用一个线性投影，原理就是一个消失点在一个点上，将三维的坐标投影到二维坐标上。

- 从着色器到屏幕坐标的变换

  要让一个顶点都显示在屏幕上，它的xyz分量要在-1,1的范围内

- 裁剪空间：任意给定位置，它的x,y,z都在一个范围之内的，-w到w，裁剪就是将[-1,1]范围内，范围之外的就会裁剪掉。

- 透视法：一个顶点成为一个OPENGLES实际的坐标之前执行一个步骤，他叫做透视法。透视之后，那个点就在坐标中了，之后所有的东西都在-1，1之间了。

  三维空间的实现：OpenGLES会吧每一个gl_position的x,y,z分量都除以w，w来表示距离的时候，使得远处的变到了与中心更近的地方。w越大，举例中心的位置就越小，

- 视口的变换

  在我们最后的结果之前，OPenGLES会将坐标x,y映射到一个区域中，这个区域是操作留出来的一个位置，被称为视口。我们将坐标告诉了OpenGLES之后，将（-1，-1，-1）(1,1,1)之外的数据裁剪掉。

  ## 案例

  1，首先更新坐标，加入新的坐标z和w。

  2.一般的操作步骤：

  - 更新坐标

    ```
    		float []tableVertices = {
    				/*
    				 * 
    				 * 00被公用，最后的-0.5变为一周，被重合
    				 * 为了可以表示颜色，这个时候在点坐标的最后加上颜色
    				 * */
    	               0f,    0f,    0f,   1.5f, 1f,   1f,   1f,         
    	               -0.5f, -0.8f, 0f,   1f,	0.7f, 0.7f, 0.7f,            
    	                0.5f, -0.8f, 0f,   1f,	0.7f, 0.7f, 0.7f,
    	                0.5f,  0.8f, 0f,   2f,	0.7f, 0.7f, 0.7f,
    	               -0.5f,  0.8f, 0f,   2f,  0.7f, 0.7f, 0.7f,
    	               -0.5f, -0.8f, 0f,   1f,	0.7f, 0.7f, 0.7f,
    
    	               // Line 1
    	               -0.5f, 0f, 0f, 1.5f,  1f, 0f, 0f,
    	                0.5f, 0f, 0f, 1.5f ,  1f, 0f, 0f,
    
    	               // Mallets
    	               0f, -0.25f, 0f, 1.25f,  0f, 0f, 1f,
    	               0f,  0.25f, 0f, 1.25f,  1f, 0f, 0f
    		};
    ```

  - 更新点数

    ```
    	//更新，从2个点变为4个点
    	private static final int POSITION_COMPONENT_COUNT = 4;
    ```

    加入了一个z,w，更新了所有的顶单，w值表现了显示出来的宽度。z坐标的作用是得到一个立体感，所以我们可以不使用z坐标，先将其设置为0.

    w变量，我们可以根据在执行过程中，远近 ，提供不同的值，比值大小代表距离的远近。

    ## 使用透视投影

    ​	前面通过正交来弥补宽高之比，现在可以通过包围整个立方体，它代表这个OpenGL最终在视口上的渲染内容，也就可以得到最终的内容。

    ## 视椎体

    ​	使用投影矩阵，场景中的并行线在屏幕上就会消失一点，举例越远就会越小，它的远端比近端大，两边的大小差距越大，范围就越宽，看到的就越多。他会有一个焦距，焦点和椎体小段的距离就是焦距。   月食

    ## 定义透视投影

    ​	创建三维，修养投影和透视同时发挥作用，投影矩阵，不可以自己做透视除法，透视除法需要某些东西才可以起作用。

    ​	如果一个距离我们很远的东西，距离我们越远就越小，所以投影矩阵，最重要的任务就是选择一个合适的w值，离我们自己越远，就会看到越小。w值越大，就会看到物体越小。

    ​	对宽度比和视野进行调整，视野越大看到范围就会越宽。

  - 在代码中使用投影

    通过公式计算，计算出一个投影矩阵，然后将其与着色器中的点相乘即可，我们定义一个坐标，然后将其传入到着色器中就可以了。

    MatrixHelper.perspectiveM(projectionMatrix,45,(float)width/(float)float,1f,10f);

    它以45°的视角，视角的举例是-1到-10.默认情况下，它的位置是0开始的，所以需要将其进行平移就会移到中间的位置（进入视椎体的显示空间中）。

    

    setIdentityM(modelMatrix,0);  将其设置为一个单位矩阵，然后将其进行平移，然后将其设置参数。我们现在有一个屏幕的矩阵，这个是平移矩阵，将二者相乘。

    

    旋转：

    ​	translateM(modelMatrix，0,0f，0f,-2.5f);

    ​	rotateM(modelMatrix,0,-60f,1f,0f,0f);

           - 第一个是模型矩阵

    - 第二个是偏移量

      
