## 变换和投影

- 相机的设置，相机设置有11个参数 

  - Matrix.setLookAtm（存储矩阵，

    偏移，

    摄像机的位置（x,y，z）,

    观察点的位置（z,y,z）,

    相机up分量(x,y,z)

    ）

- 投影（正交投影）

  - 正交投影一共有8个参数

  - Matrix.orthoM(

    存储矩阵，

    偏移，

    左右

    上下

    远近

    );

- 透视投影

  Matrix.frustumM(

  存储矩阵，

  偏移，

  左右

  上下

  远近，

  );

- 平移

  Matrix.translateM(

  ​	存储矩阵，

  ​	偏移，

  ​	x,y,z数据表示平移的距离

  )

- 旋转

  rotateM(存储矩阵，偏移，角度，x,y,z)

  x，y,z表示沿着哪一个向量旋转，比如z为1，其他为0,那么表示绕着z轴旋转。

- 缩放

  Matrix.scale(矩阵，偏移，x,y,z)

  xyz：参数表示变化的大小



上面所有变换的方式都是将矩阵相乘之后的一个最终的矩阵，然后将矩阵传递给着色器。



**绘制方式**

除了使用点和线三角形以外，还有其他

- GL_POINTS：点
- GL_LINES:线  根据坐标顺序，两个两个连成线段，12,34
- GL_LINES_STRIP:将所有的点连接起来,1,2,3,4,5,6
- GL_LINES_LOOP：123451
- GL_TRIANGLES：根据顺序三个一个三角形，三个一个三角形
- GL_TRIANGLES_STRIP:三角带
- GL_TRIANGLES_FAN:三角扇



**光照**

分为：普通光、散射光、镜面光。

- 普通光：

  普通光就是从四面八方来的光，不依赖于任何光源，没有方向性

  实现思路：

  ​	光是四面八方来的，so，我们可以将其设置参数，也可以仅仅写一个定值，将一个光源传递给片段着色器，使用当前颜色乘以光照即可。

- 散射光：

  散射光：经过平面进行反射等，反射和入射角有关系，所以求解是材质反射系数X散射光强度X入射角

  使用：先计算出光源的强度，传递给片段着色器。

- 镜面光和散射光的区别，仅仅是他们求出最终光的强度不同。

- 几种光照的组合，就是将几种光的强度相加起来，和颜色相乘。



普通光的计算方法：

环境光：使用顶点着色器将光照传递给片段着色器，gl_FragColor = finalColor*vlight

散射光：设置光强

​	每一个点乘以总矩阵，得到每一个点的位置坐标。

​	散射光光照计算

```
void PositionLight（
	法向量，
	计算结果，
	光源位置，
	光强
）{}
```



​	最总颜色*接收过来的散射光

镜面光

定位光和定向光


# 卷绕和背面裁剪

- 打开背面裁剪有什么好处?

  它会将正面绘制，背面是不会绘制的，未打开，那么就会两面都绘制。

- 怎样判断？

  默认的逆时针则为正，顺时针为反面，不过可以设置。

  打开背面裁剪 ：glEnable(GL_CULL_FACE);

  关闭背面裁剪 ：glDisable(GL_CULL_FACE);

  - 手动设置

    逆时针为正的语句：glFrontFace(GL_CCW);

    顺时针为正的语句：glFronFace(GL_CW);

  

  ## 纹理

  ​	为图元中每一个顶点都指定一个恰到的一个纹理坐标，通过坐标确定纹理区域，将选中的内容显示到指定的图元上。

  - [ ] 基本使用：
  - 第一步：创建一个纹理，将图片加入，并进行参数设置和配置。
  - 第二步：写一个着色器，将纹理传入
  - 第三步：代码获取位置，然后将其赋值。
  - 第四步：绑定纹理。

----------

- 纹理拉伸

  三种拉伸方式：

  ​	重复拉伸：纹理的大于1时，就会产生一写效果，但是这个效果是由自己设定的，比如拉伸和重复。

  



