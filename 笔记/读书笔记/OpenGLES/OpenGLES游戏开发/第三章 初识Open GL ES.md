## openGL ES

openEL ES3.0具有支持管线的功能。

### 1.x执行的流程

​	**基本处理 ：**为顶点、纹理和颜色数据的准备，并且制定绘制方式

​	**顶点缓冲**：可要可不要，如果顶点固定就可以加载到缓存中，这样可以较少IO的消耗

​	**变换和光照：**对顶点变换以及设置光照等计算

​	**图元装配：**通过顶点将数据组装成为一个完整的图像	

​	**图元处理:**就是裁剪，这个过程会增加或者减少点，根据具体情况而定**产生原因就是在根据角度的不同，我们一次看不清全部的图像，所以会出现这样的问题**）

​	**光栅化:**在显示数据的时候，我们显示的是二维，但是图像是三维，可以通过投影的方式，将图像进行投影出来，几何物体一般由矢量图和标量图，变量图由一个小的块显示出来的，光栅化的目的就是将图元变为一个个小的块

​	**纹理环境和颜色求和:**这一部分进行纹理采样，颜色求和

​	**雾:**通过当前的根据参数设置雾参数

​	**Alpha测试：**他会检测每个片元的alpha值，符合要求的采会进入下一段。

​	**裁剪空间：**会检测是否在视口内部，在进入下一阶段，不在就不会进入下一个阶段

​	**深度测试:**会进行比较片元的深度，小的进入下一个阶段，大的就会抛弃

​	**摸版测试：**将绘制区域限定在一个范围内

​	**颜色混合缓冲:**开启alpha测试之后，会将上一阶段的与缓冲中的片源混合，否则会覆盖缓冲区中的

​	**抖动：**使用少的颜色 模拟出宽的颜色，使得其更加的丰富，比如白和黑之间的灰。

​	**帧缓冲：**openGLES中并不会直接的将物体绘制出来，而是先在缓冲中进行绘制，绘制完之后在将结果显示，所以每次绘制新的一个都需要清除缓存。

### 2.x的执行流程

​	**基本处理 ：**为顶点、纹理和颜色数据的准备，并且制定绘制方式

​	**顶点缓冲**：可要可不要，如果顶点固定就可以加载到缓存中，这样可以较少IO的消耗

------------

**变换和光照：**对顶点变换以及设置光照等计算

变为了

**顶点着色器**

---------

​	**图元装配：**通过顶点将数据组装成为一个完整的图像	

​	**图元处理:**就是裁剪，这个过程会增加或者减少点，根据具体情况而定**产生原因就是在根据角度的不同，我们一次看不清全部的图像，所以会出现这样的问题**）

​	**光栅化:**在显示数据的时候，我们显示的是二维，但是图像是三维，可以通过投影的方式，将图像进行投影出来，几何物体一般由矢量图和标量图，变量图由一个小的块显示出来的，光栅化的目的就是将图元变为一个个小的块

---------

​	**纹理环境和颜色求和:**这一部分进行纹理采样，颜色求和

​	**雾:**通过当前的根据参数设置雾参数

​	**Alpha测试：**他会检测每个片元的alpha值，符合要求的采会进入下一段。

变为了

​	**片元着色器**

----

​	**裁剪空间：**会检测是否在视口内部，在进入下一阶段，不在就不会进入下一个阶段

​	**深度测试:**会进行比较片元的深度，小的进入下一个阶段，大的就会抛弃

​	**摸版测试：**将绘制区域限定在一个范围内

​	**颜色混合缓冲:**开启alpha测试之后，会将上一阶段的与缓冲中的片源混合，否则会覆盖缓冲区中的

​	**抖动：**使用少的颜色 模拟出宽的颜色，使得其更加的丰富，比如白和黑之间的灰。

​	**帧缓冲：**openGLES中并不会直接的将物体绘制出来，而是先在缓冲中进行绘制，绘制完之后在将结果显示，所以每次绘制新的一个都需要清除缓存。





### 顶点着色器

- 输入包括：

  - 着色器程序--描述着色器源代码和可执行文件。

  - 属性输入：提供颜色、顶点、灯光等。

  - uniform：顶点或者片段不变的量。

  - 采样器：纹理操作时统一变量的类型。

    **2.0和3.0的区别：2.0 的可变变量，在3.0中是输出变量。在光栅化阶段，为每个片段计算顶点着色器输出的值，这个值是插值。3.0还增加了反馈，顶点着色器可以选择性的写入一个缓冲区中。**

- 顶点着色器可以进行多种计算，比如光照、变换等参数的计算和传递。

- 语法

  - 属性：

    ```
    attribute mat4 u_matrix;[2.0]
    in mat4 u_matrix;[3.0]
    ```

  - uniform

    ```c++
    uniform mat4 u_m;
    ```

  - 输出

    ```
    varying vac4 a_color；[2.0]
    out vec4 v_color;[3.0]
    ```

  - 声明版本

    ```
    #version 300 es   使用3.0需要声明，   2.0是不需要的。
    ```





### 图元装配

​	图元就是一个个具体的图像，图元每个顶点被送到顶点着色器中，在图元装配阶段将去组合成图元。在这个阶段，需要判断是否在视椎体内，如果没有完全在就会裁剪。在图元装配阶段，点被组合成图元。

### 光栅化

​	光栅化阶段就会进行将图元具体的绘制，光栅化就是将一个完整的图转换为一个二维数组片段的过程。这些片段交给片段着色器，冉家进行在屏幕上显示。

### 片段着色器

​	光栅化的每个片段执行这个着色器，它的输入：

- 程序着色器：源代码和可执行文件

- 输入变量：光栅化用插值为每个片段生成顶点着色器的插值。

- 统一变量：片段或者顶点上不变的量

- 采样器

  它可以抛弃片段，也可以生成片段，除了多重渲染之外，片段着色器只会输出一个颜色值，多重渲染，会为每一个目标输出都会有一个颜色值，光栅化阶段生成颜色、深度、摸版和坐标，变为OpenGLES管线，片段阶段的输入。

- 语法：

  - 版本

    ```
    #version 300 es
    precision mediump float;
    in vec4 v_color;
    out vec4 fragColor;
    void main()
    {
        fragColor = v_color;
    }
    ```

    

  - 精度

  - 输入

  - 输出

### 逐（zhu）片段操作

片段着色器之后，执行逐片段操作。光栅化生成屏幕上的坐标，只能修改帧缓存区中的像素。

- 像素归属测试：判断片段是不是属于openGL上下文的，如果被另一个遮挡，就不属于这个上下文的。只有归属的像素才会显示。

- 裁剪测试：是否在显示框框中。

- 摸版和深度测试：测试输入片段摸版和深度，确定是否被抛弃。

- 混合：将新生成的片段与保存在帧缓存中的颜色值组合起来。

- 抖动：可用于最小化因为使用有限精度在在帧缓存区中颜色值会产生伪像。

  

