# 单例模式
    保证只有一个实例创建
    应用场景：
        windows的任务管理器
        windows的回收站
        项目中的，配置文件类
        网站计数器
        日志文件
        Application【Servlet中】
        spring中的bean也是单例，使用struct需要修改scope = property
        数据库连接池
        每个Servlet也是单例的
        spring mvc
    优点：只创建以后实例，减少了性能的开销，当一个对象产生需要较多资源的时候就会使用单例，。
         单例模式在系统设置全局的访问点，优化环共享资源访问
    单例模式实现方式：
        饿汉式：线程安全、调用效率高、但是不可以延迟加载。
        懒汉：线程安全、调用效率不高、可以延迟加载。
        双重锁检查：由JVM底层原理模型的原因，偶尔会出现问题
        静态内部类：线程安全，调用效率不高，但是可以延迟加载
        枚举：线程安全、调用效率高，不可以延迟加载
    饿汉式：
        实现：
            （1）将构造函数私有
            （2）创造对象
            （3）然后提供方法，返回对象。
    懒汉式：
        实现：
            （1）构造函数私有
            （2）创建变量
            （3）返回方法，加上synchronize
            调用时候的效率低
    双重锁
        实现：  
            （1）构造函数私有
            （2）创建变量
            （3）返回方法
                *判断实例是否为空
                    *空，进行加锁
                    *是否为空，加锁
                    *是否为空

                三个if，两次锁
    静态内部类：
        实现：
            （1）构造函数私有
            （2）创建内部类
            （3）返回内部类

            延迟加载，类加载，天然是安全的。
    枚举方式：
        天然单例，可以避免反射和序列化它。

    破解单例
        反射：
            使用class.forName();获得class对象，然后得到构造函数，使用构造函数创建一个实例对象。私有的可以跳过权限检查。
            如何防止，那就是在构造函数中抛出异常。第一次当然是可以的，但是只要它的里面有值了，那就不为空了，然后就抛出异常了。
        序列化:
            通过fileoutstream的方式将对象输出到一个文件中，然后将文件读取进来，生成一个对象
            防止：  
                在序列化类中，定义一个方法
                private Object readResole(){
                    return intance;
                }
                在反序化的时候，直接将这个返回，不需要创建新对象在返回。


