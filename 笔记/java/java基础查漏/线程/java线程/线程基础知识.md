###Java线程最基本的知识
1.线程与进程
    进程独享一片空间，他是操作系统分配资源的最小单元，一个操作系统中可以有多个进程在运行，得到多个应用程序可以同时运行的解决方案
    线程他属于一个进程，一个进程中的多个线程是可以共享内存的，通过cpu时间片快速的切换用于。
###上下文切换
    单个cpu再一次放弃cpu执行，到下次执行，在此过程中数据的存储和恢复。快速的切换，感觉他们是同时运行的
###记录线程的运行状态，会记录那些数据
    程序计数器：他是线程私有的，他会记录线程执行的字节码的位置
    CPU寄存器的状态，这些数据的存储与恢复会造成系统开销。
###线程的状态
    *NEW:指通过new创建，还没执行start方法的时候
    *RUNNABLE:线程正在正常运行中。
    *BLOCKED:是线程同步操作的场景，或者是进入到临界状态，等待一个线程锁的释放
    *TIMED_WAITING：进入到有时限的等待中，这个等待是放弃锁的，他需要使用notify来打破
    *terminated：run方法执行完毕
###为什么要去了解线程
    找到系统瓶颈，使用线程，更好的处理问题
###如何分析并发
    使用jps -lmv命令查看java进程的id，然后使用jstack输出线程列表

    一般问题：
        发现blocked，并且持续好久，说明瓶颈在锁的地方，发生的等待太长

        发现有线程进入waiting状态，并且持续好久，说明性能存在notify的地方，wait的速度大于notify

###使用线程
    start方法用来启动一个线程，run方法会自己执行
    run方法会为线程分配资源：
        线程栈、寄存器、程序计数器等
    sleep方法
        让线程睡眠，交出CPU
        sleep是不会释放锁的，也就是如果拥有某个对象锁，执行了sleep的时候，其他线程也是不可以访问的，
        这个方法在执行的时候会抛出中断异常
    yeild方法
        交出CPU，但不会释放锁，他仅仅是将锁释放，在下一刻的时候，可以再次的进程抢占cpu资源
    
    join方法
        是让本线程执行完之后，在执行其他的线程
    interrupt方法
        底层使用的是native的中断0，可以使得阻塞状态的线程抛出异常
    interrupted方法 static方法
    	底层调用native的isInterrupted(true)
    	表示清除状态位，只有当前线程才能清除自己的中断位
    	   
    isInterrupted方法 实例方法 作用于调用该方法的线程对象所对应的线程
    	底层调用native的isInterrupted(false)
    	表示不清除状态位，即对中断状态不产生影响
###非阻塞状态的线程
    可以使用中断来停止一个线程的运行

####setDeamon和isDeamon方法
    守护线程和用户线程的区别，他是一个服务线程，他需要依赖于创建它的线程
    当所有的线程都执行完毕的时候，守护线程会自己退出

###Object
    wait():如果调用此方法，当前线程会释放锁，所有当前线程必须拥有这个对象的monitor，因此调用wait()方法必须
    在同步代码块或者同步方法中执行
    当此方法执行之后，就会交出这个monitor，进入等待，等待后续再次获得这个监听器
    notify():方法会唤醒一个正在等待该对象monitor的线程，当多个线程都在等待monitor的时候，并不是执行，执行的是哪一个
    notifyAll():方法能够唤醒所有正在等待该对象的monitor的线程


