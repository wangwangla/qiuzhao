## 线程之间的通信
    （1）wait和notify必须和synchronized一起使用
    （2）wait方法是释放锁的，notify是不释放的在A执行的过程中，如果A线程执行了一个wait方法，那么就会将锁释放，线程在这里执行等待。
        在B线程中，执行notify方法，这个时候并不会释放锁，直到该线程执行完毕。

 ##   问题：通知延迟，那么怎样较少这个延迟。
    通知延迟的原因：
        wait方法会释放锁，但是notify并不是释放锁
    可以使用countDownLatch,这样可以不使用synchronized关键字，如果条件符合就会立刻发送通知，里面的数字,就是需要执行几次通知。
    也就是执行基础down方法，只有为0l，才可以执行通知。

    使用final修饰变量的时候，需要在定义的地方给予赋值，也可以通过构造函数进行赋值。

## 模拟消息队列 

    使用wait和notify实现一个队列，创建一个对象作为锁，然后在判断队列满的时候将put方法堵塞，如果为空的时候将take堵塞，当然了在执行了put和get之后，会对通知对方。

## ThreadLocal
    线程的局部变量，一种多线程间并发访问变量的解决方案，是不加锁的。它以空间换取时间的方案，他为每一个线程创建一个副本，保证线程的安全。
    在竞争很激烈的时候，可以减少锁的竞争。

    总结就是一句话：每一个线程一个ThreadLocal

## 单例模式
    再多线程中是不要使用的，使用双重锁检查或者静态内部类的方式
    静态内部类的实现，也是很好的，一工9行代码
    public class Demo{
        private static class s{
            private static s s1 = new s();
        }
        public static s getS(){
            return s.s1;
        }
    }


## 双重锁为什么要加volatile
    假设没有关键字volatile的情况下，两个线程A、B，都是第一次调用该单例方法，线程A先执行instance = new Instance()，该构造方法是一个非原子操作，编译后生成多条字节码指令，由于JAVA的指令重排序，可能会先执行instance的赋值操作，该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，之后instance便不为空了，但是实际的初始化操作却还没有执行，如果就在此时线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的Instance对象，所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。

    创建对象可以分解为如下的3行伪代码memory=allocate(); //1:分配对象的内存空间ctorInstance(memory); //2:初始化对象instance=memory; //3:设置instance指向刚分配的内存地址上面3行代码中的2和3之间，可能会被重排序导致先3后2,

      类从加载到虚拟机开始：加载、验证、准备、解析、初始化、使用、卸载
      这五个是确定的，但是初始化和解析，这个是没先后顺序的。
    
