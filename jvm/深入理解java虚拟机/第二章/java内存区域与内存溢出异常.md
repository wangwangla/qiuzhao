
### 1.概述：
```
我的总结：
    c和c++拥有高的内存管理，可以对内存进行操作，Java语言的内存管理交由java虚拟机在管理，这样在创建对象的时候，最后不需要自己delete这个空间，但是如果处理内存溢出和内存泄露，这个时候就必须了解虚拟机才可以。

```
### 2.运行时数据区域
```
我的总结：
    在java程序运行的过程中，会将内存划分为若干个不同的区域，不同的区域完成不同的功能，它的主要分为
    程序计数器、方法区、虚拟机栈、本地方法栈、堆

```
## 2.1.程序计数器
```

我的总结：
    首先它是指示当前字节码文件执行到的行号，在执行java方法，指示的是java字节码的行号，如果执行的是本地方法，那么就是null，他也是唯一一个没有内存溢出错误的区域。
    他通过指针的指示完成程序代码的执行，分支、循环、递归、异常处理、线程恢复等操作。

    java虚拟机是多线程执行的，所以他通过轮流的方式来执行，由于某一个时刻去执行另一个任务，这个任务可能未执行结束，为了可以接着执行，所以需要记住这个标记，所以他是私有的，各个程序计数器是互不影响的。

```
## 2.2.java虚拟机栈
```

我的总结：
    java虚拟机栈是一个私有空间，他存储的是栈帧，它的声明周期同线程，每个方法的执行，都会创建一个栈帧
    栈帧存储的是局部变量表、操作数栈，动态链，方法出口，方法的执行，就是入栈和出栈的过程。

    这个区域会有两种溢出异常：
        栈溢出：如果深度超过了最大深度就会出现栈溢出
        内存溢出：如果创建栈的时候，无法申请到足够的内部，就会出现内存溢出。
补充：
    局部变量表：存储的是各种基本数据类型和对象引用。

```
## 2.3本地方法栈
```

    同于java虚拟机栈，他只是执行的是本地方法
```
## java堆
```
   
    java堆是内存占用最大的一块，他也是垃圾主要回收的位置，他在虚拟机启动的时候创建，它的所有线程共享的区域，她存储的主要是数组和对象。【主要是因为栈上也可以存储，逃逸技术】

    现在的垃圾回收主要是分代垃圾回收，所有为了方便垃圾回收，他会将堆分为年轻带和老年代，在细分eden、Survivor【From survior /to survior】

    java虚拟机可以是不连续的单元，只有逻辑上连续就可以了。

    对于大小可以进行设置，如果堆上的内存无法扩展，那么就会发生内存溢出溢出

补充：
    内存溢出和内存泄露
    内存泄露是即用不了，也回收不了
    内存溢出是超出了内存的范围，超出了最大值

```
## 方法区
```   
   
    方法区他是共享的，它主要存储的是类信息，编译后的字节码文件，静态变量，常量。
    有时候也会将方法区称为是一个永久代
    1.7的时候将常量池溢出

    java虚拟机对于方法区的大小是可以选择固定或者向外扩展的，但是并不要求，必须有垃圾回收，它的垃圾回收量是比较少的

    对象卸载也会发生在这个区域中，当分配内存无法达到需求的时候，也会发生内存溢出的

```
## 运行时常量池
```

    他是方法区的一部分，class文件除了有类的版本、字段、方法、接口等信息，还有常量信息，用于存放编译时期各种字面量和符号引用。

    无论那一部分的内容都必须有一定的规范，这样才会被加载和执行，

    这一部分的数据，不一定要在编译时期产生，在运行的是也是可以产生的 。比如String的intern

```
## 直接内存
```

不是java虚拟机中的数据区的一部分，也不是虚拟机规范中定义的内存区域，但是他被时长应用，也会造成内存溢出。
他是通道与缓冲区的I/O方式。

```
### Hotspot
```

```
## 它是如何创建对象的
```
    平时创建对象可以通过克隆和new，序列化，反射
    （1）虚拟机做了什么？
        遇到new关键字
        ·会去检查这个指令的参数是否可以在常量池中定位一个类放入符号引用，并且检查是否已经被加载、解析、初始化。
          未已经初始化，那就先执行类的加载，解析初始化【说点别的：我面试的时候，说在方法区查找，这个并没哟错，常量池本身就在方法区中，1.7之前】
        ·检查过后，开始分配空间，也就是在堆中划分一块内存
        指针碰撞:
            （1）概念：假设内存是规整的，所有的用过的数据内存都放在一边,内存指示的位置，分配的时候将指示器向后移动分配内存大小个距离
            （2）条件：内存必须规整
        空闲列表：
            （1）概念：内存是不规整的，交互交错的，这个时候就必须有一张表记录，那一块的内存是可以使用的，在分配的时候，找出一段可以使用的分配给实例，并更新表

```
# 面试
```
    
        对象创建时非常频繁的，假如一个对象创建的时候，在A分配空间，但是指针还没有来得及更改，同时B又同时使用原来指针分配的空间？？？
        （1）一种就是在分配的时候进行同步处理，采用虚拟机提供的CAS配上失败重试的方式保证更新操作的原子性
        （2）在内存分配的动作按照线程划分在不同的空间之中进行，即就是每一个线程在java堆中预先分配一个小的内存
            那个线程要分配空间，那个线程的缓冲区上分配

    （2）分配完成之后，就会将其初始化为0值，如果是同缓冲区，那么就是在分配缓冲区的时候执行这一操作。
         它可以保证在程序未在构造函数中赋初值就可以使用，可以访问到这些0值
    
        内存分配了   0值也赋予了  下来应该是他属于谁了

    （3）将属于哪一个实例。如何找到元数据信息。对象的哈希码、对象的GC分代年龄都放在对象头中

    （4）因为默认都是0值，这个时候按照程序员的意愿来进行初始化。

```
## 对象的内布局
```

    对象的内存布局分为：对象头、实例数据、对齐填充
    （1）对象头
        对象头包括两部分：
            存储对象自身的运行时数据：
                如哈希码、gc分代年龄、锁状态、线程持有的锁、时间戳，它的长度和系统的位数有关
                那么多数据，他有不是数据，那么就采取一些措施将其变的更加的小。
            类型指针：
                对象指向它的类元数据的指针，通过它来确定这个对象是哪一个类的实例。
                但是这个不是必须的，查找数据的指针也不一定需要通过类型指针，也就是说查找对象的元信息并不一定需要通过对象本身
            
                假如是一个数组，那么就需要在对象头中有这个数组的长度，但是这个长度在元数据中是没有的。
    （2）实例部分
        实例部分真正存在数据的部分，也是存在各种属性字段的地方，无论是父类的还是自己的，它的顺序受到虚拟机的分配策略和源码的的影响
        举例：Hotspot
        它的存储将相同宽度的数据放在一块，不同数据放在一块，，如果CompactFields参数为true的时候，那么子类中较窄的会放入父类空隙中。
    （3）对齐填充
        这不是必然的，起到占位的作用
        在Hotspot中，自动存储管理系统要求起始地址为8的整数倍，即就是头为8的整数倍，若没有对齐，就会去填充。

```
## 对象的访问定位
```

    对象创建结束了，下来是使用对象，那么如何定位？？？？？？？？
    执行方式是由虚拟机的实现决定的，目前主流的有两种句柄指针和直接指针
    （1）句柄指针
        通过指向句柄池中的地址，句柄池中有对象实例和数据类型的具体地址。
    （2）直接指针


```
## outofMemoryError
```

    除了程序计数器，其他的地方都会发生内存溢出

    案例：
        参数说明：Xmx：堆最大值   Xms：堆内存最小值
                HeapDumpOnOutOfMemoryError：可以在发生异常的时候将数据dump处理。
        为了防止扩展，那么就将两个设置一样即可。

    堆：在创建对象达到一定数量，内存无法分配的时候，就会抛出内存溢出异常。
        java heap space:发生异常的时候，如何去分析它。
        （1）首先确定是溢出还是泄露
            是：分析链，为什么它活着，是不是必须活的，然后就可以定位代码【是泄露这个应该是不是活的，应该死】。为什么活，然后发现问题，解决问题。
        （2）不是，那么就是必须活，查看是否可以调大，是不是可以提前让他们死一部分，生命周期没有必要这么长。
    虚拟机和本地方法栈：
        Hotspot中两种是一起的
        栈中有两种异常，栈溢出和内存溢出
        线程请求深度超出栈的深度
        内部溢出，创建的栈帧所需的内存大于实际的内存。
    
        结果分析：
            单线程下，无论是如何都会发生栈溢出
            多线程下，对于每个线程分配的栈的大小越大，，就越容易发生内存溢出。

```
### 方法区和运行时常量池溢出
```
    
    string的intern方法，如果常量池中有救直接使用，如果没有就将它创建，然后返回引用。
    java1.6的时候，会执行复制，java1.7的时候，返回的就是一个引用。

    什么时候关注：
        比如代理还有在Jsp页面，都会产生大量的字节码文件。