# java内存模型与线程
```
```
## 多任务处理的可能
```
    计算机的计算能力提高了，运算速度与存储速度的差异太大，造成CPU的浪费
    每秒处理的事务数，也是衡量一个服务器好坏的一个指标，但是这个又和并发能力有密切的关系，线程并发协调的越有条不紊，效率越高

```
## 硬件效率造成的问题
```
    一个任务需要使用CPU进行计算，还需要进行与IO进行交换，但是内存读写和CPU速度的差异，所以需要一个高速的缓存来处理，CPU计算与缓存交互。

    问题：缓存一致性问题【每个处理器为了效率都会有一个缓存，但是缓存中的数据都来自于同一块内存】

    处理器在为了更好的时候资源，会将内存进行乱序优化，将代码进行重组，保证结果与顺序执行是一样的结果，也就是编译时期指令重排序优化。
```
## 内存模型
```
    java虚拟机屏蔽这一操作系统和硬件之间的访问差异，可以使得Java程序可以在各种平台上游相同的访问结果。

```
## 主内存和工作内存
```
    java内存模型的主要目标识定义程序中各个变量访问规则，就是将数据存入内存，再从内存中取出变量这里面的一些细节。【变量都是一些共享 的，不共享的是不会出现竞争问题的】

    每一个线程有自己的工作内存，它将主内存中的数据复制到工作内存中进行执行，而不是直接和主内存直接通信，各个线程也是无法访问别人的工作内存的，主内存也是各个线程之间进行通信的通道。【所以每次修改完成之后就不知道这个里面数据是以哪个为准，所以也就存在线程安全的问题，之前的synchronized和lock都是将这里的内存锁起来，然后一个操作结束，另一个才可以进去接着执行】

```
## 内存建交互操作
```
    一个变量从主内存进入工作内存，从工作内存到主内存，这些操作都是原子的，不可以在分的。
    主内存变量：
        lock：将主内存中的变量上锁
        unlock：将主内存中的变量上锁
        read：将主内存中的数据加载到工作内存
    工作内存：
        load：架构工作内存中的数据加载到工作引擎【变量放入副本中】
        assign：赋值，将值赋值给工作内存中的变量
        store：存储，工作内存中的变量传输到主内存
    主内存：
        write：将工作内存中的数据写入主内存。

```
## 对于volatile变量的特殊规则
```
    volatile修饰的变量可以在线程之间可见，一个线程修改之后，另一个线程是立马可见的。但是他不是安全的。在一些需要线程安全的地方，仍然是需要synchronized来保证安全的；

    我个人认为:在并发这里始终记住，机器执行的是机器码不是代码。

    第二个作用就是禁用代码的重排序

```
## 原子性、可见性与有关性
```
    原子性：基本数据类型都是原子的，但是对于long和double是比较特殊的
    
    java内存模型提供了lock个unlock，但是这种方式并未向用户提供使用，但是如果使用synchronized也是monitorenter和monitorexit隐式的使用方式。

    可见性：一个线程发生了修改，其他线程可以立即感知
    java内存模型通过修改之后将数据刷新到主内存，在使用变量前先从主内存刷新值，然后在使用。
    还有保证可见性的是final和synchronized

    有序性：java天然有序【自己看自己有序，看别人无序】
    java提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就是禁止指令重排序，对于synchronized是由一个变量在同一个时刻只允许一条线程对于其进行lock操作，这个规则决定了持有一个锁的两个同步块只能串行的进入。

```
## 先行发生原则
```
    它判断数据是否竞争、线程是否安全的主要依据，可以解决两个线程之间是否存在冲突的所有问题。
    两个操作之间的偏向顺序
    举例：两个线程A操作对B操作有影响，他们之间保持着先行关系，结果就是正确的，加入C线程来了，在二者之间出现，那么就会出现问题。

```
## 内存模型中天然的先行关系
```
    程序次序规则：
        一个线程内，按照控制流程的顺序进行，准确说不是代码的顺序
    管程锁定规则：
        同一把锁，未加锁的unlock先行于后面的lock操作。
    volatile变量规则：
        写操作先行于后面的读操作
    线程启动项：
        Thread的start（）方法先行于此线程的每一个操作
    线程终止规则：
        线程中所有的终止操作先行于发生对此次线程的终止检测，可以通过Thread.join（）方法结束等手段检测。【不理解】
    线程中断规则：
        对于他的interrupt（）方法调用先行发生于被中断线程代码检测到中断发生
    对象终结规则：
        一个对象的初始化完成先行于发生于他的finalize（）方法的开始。
    传递性：    
        A优先于B，B优先于C，A有限于C
        