JVM知识总结
1.JVM的内存区域
基本分为：方法区、堆内存区，本地方法栈、虚拟机栈、程序计数器

方法区:主要是用于存储虚拟机加载的类信息、常量、静态变量，以及编译后的代码等信息

jdk1.7之前，方法区是堆的一个逻辑部分【一片连续的对空间】，但是为了与堆区分，方法区中有一个 名字‘非堆’也有人用‘永久带’表示方法区。

jdk1.7之后去永久代，已经将字符串常量池等移动到堆中，这里只是将字符串常量池的数据移动到堆中去了

jdk1.8已经不存在方法区了。原方法区中存放的类信息、编译后的代码数据等都已经移动到了元空间中，元空间没有在堆中，而是在本地内存中

去永久带的原因：
（1）字符串在永久带中，容易造成性能问题和内存溢出。
（2）类以及方法信息很难确定其大小，因此对永久带的大小指定比较困难，太小容易出现永久带溢出，他打易造成老年代溢出。
（3）会为gc带来复杂度，并且回收率低。


2.堆内存：
主要用于存储【对象】和【数组】，他是JVM管理的内存中最大一块区域，对内存和方法区中的线程被所有共享，在虚拟机创建的时候创建，在垃圾回收中，由于现在的收集都基本采用分代收集算法，因此堆还可以分为新生代和老年代。

3，程序计数器
程序计数器是一个很小的区域，可以看做事当前先线程的执行的字节码的行号指示器，每一个线程都有唯一的一个程序计数器，他是线程私有的一块空间，此外，也是一个不会发生内存溢出的区域。

4.虚拟机栈
虚拟机栈也是每一个线程私有的空间，为每一个线程分配一个虚拟机栈，每一个虚拟机栈有很多的栈朕，每一个帧中存储的是局部变量表。操作数栈，动态链接等，每线程执行每一个方法，就代表了这个方法对用的栈帧也已经进入到虚拟机栈并且处于栈顶的位置，每一个java方法从被调用到结束，就是一个栈帧从入栈到出栈的过程

5.本地方法栈
本地方法栈与虚拟机栈一样，不过他是执行本地方法

6，元空间：jdk1.8已经不存在永久代了，替代它的是元空间，和永久代类似

##JVM内存溢出
1.堆内存溢出
堆内存中主要是存放对象的、数据的。也是最大的一片区域，只要GC roots可达就可避免垃圾回收机制清除这些对象，不过当堆非常大的时候，就会发生溢出

新创建的对象放在新生代中，新生代满后就会执行一次GC，不满足条件的使得进入老年代，如果老年代满后，就会执行一次FULL GC，之后内存依旧不够，那么就抛出异常。

原因：一次从数据库中取出太多的东西  代码存在死循环  集合中存入的东西太多了。 

2.虚拟机栈、本地方法栈溢出
    当线程请求栈的深度大于虚拟机所允许的深度，就会抛出栈溢出，简单说就是栈帧的个数太多了

    如虚拟机在扩展是无法申请到足够的内存空间
    虚拟机中可以栈使用的是==可用物理-最大堆-最大方法区
    举例:如果虚拟机栈中有2G的物理内存，最大的对内存为1G,方法区为512M，那么栈就为512M，当无法扩展新的线程的时候就会产生溢出

    解决方法：如果线程少的时候，当深度过大，就会出现栈溢出的现象==========》增加栈的深度
    如果无法得到更多的内存开辟栈空间，就会发生栈溢出，可以通过===========》 将栈空间缩小


3.方法区溢出
    方法区主要存储，字节码、常量、静态变量，类信息，溢出的原因是没有足够的内存来存放这些数据

    1.7将常量池的东西移动到了堆中。1.8就没有了。
    怎样会溢出呢，当然是GC roots，

    如何模拟呢：jdk 1.6就可以通过创建常量来模拟  1.7只能使用创建方法来模拟了  1.8就别纠结了

4.JVM
    垃圾回收，就是通过垃圾回收机制回收内存中没有用的对象清除掉。垃圾回收涉及到内容有：
        对象是否已死、什么收集算法、什么时候收集、选择适当的垃圾回收机制

    （1）对象是否已死
        1）判断是否已经死亡，以后不会再用到，使用方法是引用计数器和可达性判断
                引用计数算法：给每一个对象增加一个引用计数器，每当有一个地方使用就将计数器加1，没当有地方不在引用就减去1，当计数器为0的时候
                就将其回收掉
                优点：使用简单
                缺点：相互引用的时候，无法将数据正确的删出

            可达性分析算法
                了解分析算法之前需要使用以下GC roots，垃圾回收的起点，可以作为有虚拟机中本地方法的引用对象，方法区中静态属性引用对象、本地方法栈中引用的对象


                当一个对象到GC Roots没有任何链的时候，就说此对象是不可用的，是死对象，但是也不是必死无疑，接着会判断是否有覆盖finalize（）方法或者方法是否被调用【有必要执行finalize方法】，如果在finalize中重新的引用了GC roots引用链上的对象关联就会拯救自但是一般不建议这样做，因为他不会立即执行。

            方法区的回收
                方法区中回收主要是常量，无用的类   判断他们在某些地方是否被引用
                判断条件：
                    该类所有实例可以被回收（堆中不存在任何该类的实例）
                    该类的classLoader已经被回收
                    该类的class对象，在任何地方都没有被引用

            怎样的引用有效
            引用的对象，方法区静态属性的引用对象、方法区中常量引用的对象，本地方法栈中的引用对象
    （2）什么收集算法
        复制-清除        标记-清除         标记-整理

        复制-清除
            将内存分为大小相同的两份，每次只使用一份内存，当用完之后，就吧存活的对象全部复制带另一块上，同时把使用这块内存空间全部清除掉
            缺点：内存只使用一般

        标记-清除
            分为标记和清除两个阶段，首先标记处所由需要回收的对象，标记完成后统一回收的所有标记对象
            缺点：标记个清除效率不高，   标记之后会产生大量的不连续的内存碎片
        标记-整理
            先对可用对象进行标记，然后所有的被标记的对象向一个方向移动，最后清楚可以用对象边界之外的内存

        分代回收机制
            把堆内存中分为新生代和老年代，新生代有分为Eden区，From Survivor和To Survior，一般新生代基本是少部分，所有采用的是复制算法，只需要复制少量存活对象就可以完成垃圾回收
            老年代存活率高，就采用标记清除和标记整理。

            分区基本分为：
            大多数情况下，新的对象都分配在Enden中，当Enden中没有空间可以使用的时候，就进行一次GC操作，清理掉无用的对象。
            清除之后：Enden和From Survivor中存活对象如果小于To survivor的存储空间，那么久进入到To Servivor,负责直接进入到老年代
            Enden和From Survivor中存活且进入到To survivor的对象年龄增加一岁，每一次GC增加一岁。当到达15的时候就进入老年代
    （3）什么时候收集
    （4）选择适当的垃圾回收机制






==========================================================================================================================
JVM工作原理和流程
1.java详解JVM工作原理和工作流程
执行流程：javac执行java编译器，将java变为class二进制，jvmk可以执行的二进制文件。在将字节码加入装入到内存中，一旦字节码进入虚拟机，就会被解释器执行，或者有选择的变为机器码执行

2.JVM的存在未java提供了跨平台型，当java程序启动的时候就会启动一个实例，运行结束，实例也就结束了。

    JVM的两种机制：  类装载子系统   执行引擎
    类装载子系统：装载具有适合名称的类或者接口
    执行引擎：复制执行包含在已装载二类或者接口中的指令

    JVM都包方法区，堆、本地方法栈、虚拟机栈、程序计数器

    java代码编译的过程和执行的过程：
        java代码编译和执行的整个过程大概为：Java代码，编译之后形成class字节码，将字节码装入内存，将内存的中的字节码装入虚拟机，一旦进入就会知执行，或者即使代码选择器就会选择性 的执行。

        java代码编译   java字节码加载   java字节码执行


        java代码编译：分析输入  注解处理  语义分析和生成class  


        类加载：Bootstrap classLoader 加载环境变量中的



JVM在启动的时候，通过设置-Xmx或者-XX来显示的设置堆和永久代的内存大小

（1）为什么不直接设置JVM的大小，而是涉及区域的大小
（2）JVM管理的有多少个区
（3）每个区有什么作用
（4）如何管理分区

背一遍：
    方法区：用于存储类信息、常量、静态常量、编译后的字节码文件，他是堆的一部分，但是为了分开说，我们叫他永久代
           平时用到的类名、方法名  字段名称  访问权限
  堆  虚拟机栈   本地方法栈   程序计数器


