JVM知识总结
1.JVM的内存区域
基本分为：方法区、堆内存区，本地方法栈、虚拟机栈、程序计数器

方法区:主要是用于存储虚拟机加载的类信息、常量、静态变量，以及编译后的代码等信息

jdk1.7之前，方法区是堆的一个逻辑部分【一片连续的对空间】，但是为了与堆区分，方法区中有一个 名字‘非堆’也有人用‘永久带’表示方法区。

jdk1.7之后去永久代，已经将原本的方法区的静态变量，字符串常量池等移动到堆中，这里只是将字符串常量池的数据移动到堆中去了

jdk1.8已经不存在方法区了。原方法区中存放的类信息、编译后的代码数据等都已经移动到了元空间中，元空间没有在堆中，而是在本地内存中

去永久带的原因：
（1）字符串在永久带中，容易造成性能问题和内存溢出。
（2）类以及方法信息很难确定其大小，因此对永久带的大小指定比较困难，太小容易出现永久带溢出，他打易造成老年代溢出。
（3）会为gc带来复杂度，并且回收率低。


2.堆内存：
主要用于存储【对象】和【数组】，他是JVM管理的内存中最大一块区域，对内存和方法区中的线程被所有共享，在虚拟机创建的时候创建，在垃圾回收中，由于现在的收集都基本采用分代收集算法，因此堆还可以分为新生代和老年代。

3，程序计数器
程序计数器是一个很小的区域，可以看做事当前先线程的执行的字节码的行号指示器，每一个线程都有唯一的一个程序计数器，他是线程私有的一块空间，此外，也是一个不会发生内存溢出的区域。

4.虚拟机栈
虚拟机栈也是每一个线程私有的空间，为每一个线程分配一个虚拟机栈，每一个虚拟机栈有很多的栈朕，每一个帧中存储的是局部变量表。操作数栈，动态链接等，每线程执行每一个方法，就代表了这个方法对用的栈帧也已经进入到虚拟机栈并且处于栈顶的位置，每一个java方法从被调用到结束，就是一个栈帧从入栈到出栈的过程

5.本地方法栈
本地方法栈与虚拟机栈一样，不过他是执行本地方法

6，元空间：jdk1.8已经不存在永久代了，替代它的是元空间，和永久代类似

##JVM内存溢出
1.堆内存溢出
堆内存中主要是存放对象的、数据的。也是最大的一片区域，不过当堆非常大的时候，就会发生溢出

新创建的对象放在新生代中，新生代满后就会执行一次GC，不满足条件的使得进入老年代，如果老年代满后，就会执行一次FULL GC，之后内存依旧不够，那么就抛出异常。

原因：一次从数据库中取出太多的东西  代码存在死循环  






























