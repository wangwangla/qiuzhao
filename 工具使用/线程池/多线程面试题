java多线程面试题
1.多线程有什么用？？
    可以发挥CPU多核的作用.
    阻止阻塞：单线程下，如果一个线程发生阻塞，那么其他的都需要等待，但是对于单核来说，这并不是什么好事情，因为会会有上下文切换
    但是单核使用的目的那就是防止阻塞

    便于建模：大的任务分成小的任务

2.创建方式：3种
    实现Runnable  继承Thread  实现callable
    Thread可以避免在继承多个类的情况下会有问题，选择Runnable
    在不考虑多个类的时候，两个都可以
    在想知道线程当前的执行状态，就需要使用callable

    好处：避免了线程执行的未知性
    public class Demo12 implements Callable{
	    public Object call() throws Exception {
		    // TODO Auto-generated method stub
	    	return null;
	    }
    }

3.cyclicBarrier和CountDownLatch的区别？？
    （1）CyclicBarrier的某个线程运行在某个点上，该线程停止，知道所有的线程都到达，所有的线程都到达这个点，所有线程才一起重新运行
    CountDownLatch不是，某个线程到达某个点之后，只是给某个值-1，并不是停止，而是继续执行

    （2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个

    （3）CyclicBarrier可以重用，CountDownLatch只能使用一次，计数器为0就不可以在用了

4.volatile关键字的作用
    多线程只要围绕原子性和可见性两个特性展开的，使用volatile修饰的变量，保证多线程的可见性
    使用volatile是禁止对语义进行重排序的

5.线程安全
    一个操作，在多线程情况下执行和单线程情况下执行，结果是一致的，那么现象就是安全的

6.  高并发、认为执行时间短的业务怎样使用线程池？？
    线程池可以设为核数+1，减少上下文切换

    并发不高，任务执行时间长的业务怎样使用线程池？
    （1）IO密集型任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，加大线程数量
    （2）如果是计算密集型，这个时候需要使用CPU，所以将数量设置少一点

    并发高、业务执行时间长的业务怎样使用线程池？？
    并发高可以做缓存 第二加服务器 对于线程还需要看执行的具体业务

7.同步方法和同步代码块选择哪个？？
    同步代码块：就是代码块之外的异步处理   一条原则：范围越小越好
    但是也存在一个粗锁，对于本身就是锁的代码，这个时候是不需要这样做的

8.对于HashTable的size方法只有一条语句，为什么还要做同步？？
    （1）同一时间，只能有一条线程执行固定的同步方法，但是对于类的非同步方法，可以有多个同时访问，如果在size的时候，这个时候也有一个put操作
    （2）执行的永远不是代码，而是机器码

9.什么是AQS？？
    AbstractQueueSynchronizer是以双向队列的形式连接所有的Entry，所有的等待线程都被放在一个Entry中并连城双向队列

10.悲观锁和乐观锁
    悲观锁在执行期间，总是任务会有竞争发生，数据总是被修改，这个时候，执行的时候总是加锁，
    乐观锁：在执行期间，认为数据并不会发生修改，它是由CAS进行的，如果发生冲突  

11.java内存模型？？
    java内存模型定义了一种对线程访问java内存的规范，内存模型分为主内存和工作内存
    主内存是共享的，工作内存是修改的区域，每次操作在构造内存中进行，然后再讲数据放回到主内存中
    happens-before：先行发生，同一个锁，去掉锁先于获取锁

12.synchronize里面的代码是简单的代码，执行时间非常快，等待的线程枷锁，是不太可能的，阻塞会用到用户和内核的切换，那么就让其不再阻塞，而是
在哪里循环，这就是自旋。

13.Thread.sleep(0)的作用是什么？？
    java是抢占式的线程调度算法，因此可能出现某线程可能一直获取不到执行权， 这个时候可以使用它进行手动控制，触发一次分配时间片的操作

14.java是抢占式的，一个线程执行之后，操作系统会根据优先级、饥饿程度等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

15.如果一个线程池满了，当有任务来的时候？？
    如果是无界的队列，就将其继续加入到队列中
    如果是有界的队列，如果队列么有满就加入到队列。如果队列满了就开线程继续执行，如果线程数量大于maxThreadPool的时候，就采取拒绝策略
    
16.不可变对象，具有内存可见性，不需要进行其他额外的同步处理，提升了执行效率

17.如果唤醒一个阻塞方法
    如果调用了wait()/sleep()或者join()方法而堵塞，可以会使用中断，如果是IO，那就无能为力了

18.Synchronize和ReentrantLock的区别？？
    （1）ReentrantLock是一个类，synchronize仅仅是一个关键字，所以她又更多的方法并且可以被继承
    （2）ReentrantLock可以获取锁信息
    （3）可以设置时间，防止了死锁

19.然后判断，是否有锁？？  haodLock(object obj)方法


20.java异常的理解？？区分一下运行时异常和一般异常，遇到哪些异常，他们是怎样产生的？？

21.







































































































