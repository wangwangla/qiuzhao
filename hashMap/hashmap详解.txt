Map存入的是key - value在软件开发中是一个经典的结构。
hash:使用一个散列的结构，通过hash算将将一个长度通过一定个iidngzhi
Map：存储的是一个key-value
总结：通过HASH出来的值，然后通过值定位到map然value存储到这个map中

hashMap：底层实现是数组+链表的实现

java 1.7
        源码分析：key value
        初始化容量1<<4  16
        最大的容量1<<30
        扩容因子  0.75f  在容量的3/进行扩容
        创建一个数组
        扩容变量：null就去默认值
        有三个构造方法


        put
        如果数组是没有初始化，就会进行初始化
        key是可以为null，那么就会进行特殊处理了一些，将NULL当做Key处理，如果不为null，那么就执行hash
        得到数组的下标，然后对数据进行遍历Entry，如果key的hash等于hash值，或者说key已经存在，那就将原来的值返回，将新值存进去。

        key值不会覆盖，他会新值替换旧址=值

        什么时候扩容，当put的事实，参数慢3/4的时候进行扩容，

        一定是两倍，默认是16.k扩容一直都是偶数。  


    （1）是由segment和HashEtry组成
    （2）核心变量：
        初始化桶的大小，桶的底层是数组，所以这是默认数组的大小      16
        桶的最大值                                              1左移30
        默认的负载因子                                          0.75f
        table真正存放数据数组                                   
        Map存放数量的大小
        桶的大小,可以在初始化时显示指定
        负载因子，可以在初始化是显示指定

给定的默认容量为16，负载因子是0.75，map使用使用的使用会不断的增加数据，当达到16*0.75就需要
扩容，扩容就需要有数据的复制，就需要消耗性能【尽可能的减少扩容】

Entry是hashMap中的一个内部类，从他的成员变量很容易看出：
    （1）key就是写入时的键
    （2）value就是写入时的值

    开始的时候hashmap有数组和链表组成，所以这个next就用于实现链表结果
    hash存放当前key的hashcode


put操作：首先判断当前的数组是否需要初始化
        如果key  null，返回hash为0，那么就将null存进去
        根据key查找hashcode，根据hashcode定位出所在的桶
        如果桶中是一个链表则需要将桶变量hashcode，key是否和传入key相等
        如果相等，那就将其值返回
        如果是空，说明没有数据存入，新增一个Entry对象写入当前位置。

        当写入的时候，需要判断是否扩容，并将当前的key重新定位

get操作：
        首先也是根据key计算出hashcode，然后定位到桶中
        判断是否为链表
        不是就根据key的hashcode来获取值
        为链表，则需要遍历知道key和hashcode相同的时候
        啥都没有就为null

Java1.8

        1.7中有一个问题，如果hash冲突太多的时候，就会造成链表越来越长，这样查询就会比较慢，时间复杂度也是很高的

        将链表改为了红黑树和阈值，将hashEntry修改为Node
        hshEntry变为了Node

        Node的核心和hashEntry一样，存放的是key value hashcode  next的数据

        put操作之前判断桶是否为null，空的话就需初始化，根据当前的key的hashcode定位到具体桶中进行判断是否为null
        如果为null，就创建一个桶
        如果有桶，那么就比较桶中的key key的hashcode于写入的key是否相同，如果相同就将值付给e，
        如果当前桶为红黑树，那么需要按照红黑树将数据写入桶中

        如果是链表，就需要将当前的key value封装成一个节点，写入当前桶中

        判断阈值，如果大于阈值，那么就变为红黑数

        如果找到相同的key就直接退出遍历

        如果key中有值，然后将其覆盖掉
        最后判断是否扩容


        get操作
        （1）首先将key hash之后取得锁定位的桶
        （2）如果桶为null,那么就直接返回null
        （3）否则判断桶的第一个位置的key是否为查询的数据key，如果是就返回，如果不是就进行遍历链表
        或者红黑树
        1.8进行优化，提高了效率


        HashMap在多线程情况下会出现扩容的时候出现死循环



存在的问题：容易成为死循环

原因：hashMap扩容的时候会调用resize()方法，这里并发操作易生成一个桶上形成环形链表，计算出index正好是
环形链表的下标就会生成死锁





遍历方法：第一种使用迭代器 使用entrySet进行遍历
        第二种通过获取key的方式进行遍历

        没有做同步操作，会出现问题，甚至死循环


concurrentMap
        由数组和HashEntry组成和hashMap一样   也分为1.7和1.8


        1.7
        是有数组和链表组成，segment是CurrentHashMap的一个内部类
        核心变量：keySet和entrySet
        基本和hashMap一样，唯一区别就是核心数据是value，以及链表都是volidate修饰，保证数据 可见性


        原理上采用分段锁技术，其中segment继承Lock不同于hashTable无论如何操作，都需要有相同的同步处理，
        理论上都支持一定数量并发，并且不会影响到其他的segment


        put操作：通过key定位到segment，之后在对应的segment上进行put

        虽然可见，但是volatile不保证原子性，所以put是需要枷锁
        


put流程：首先第一步的时候，先去获取锁，如果获取锁失败，那摸有其他锁竞争，然后进行重试，重试次数达到一定知道时候
改为堵塞锁获取

当获取锁成功之后，就可以对进行put操作
        第一步首先进行hash确定segment中的HashEntry
        第二步：变量entry，如果不为null，就判断传入的key的遍历中的key是否相同，如果相同就将老值返回，将新值传入
        如果为null，那就创建一个HashEntry并加入到segment中，同时会判断是否需要扩容
        最后取消锁


get操作：只需要建key定位到hash，然后具体到segment之后，在通过一次hash定位到具体的元素
        因为数据都使用的是volatile，所以获得数据都是最新的
        非常高效，因为不枷锁


1.8  1.7解决了并发的问题支持N多访问

但是变量链表的速度太慢了

因此有调整
        抛弃了segment分布锁，采用CAS+Synchronize保证并发安全性。

        将Entry修改为Node



















