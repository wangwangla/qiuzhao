Map存入的是key - value在软件开发中是一个经典的结构。

hashMap：底层实现是数组+链表的实现

java 1.7
    （1）是由segment和HashEtry组成
    （2）核心变量：
        初始化桶的大小，桶的底层是数组，所以这是默认数组的大小      16
        桶的最大值                                              1左移30
        默认的负载因子                                          0.75f
        table真正存放数据数组                                   
        Map存放数量的大小
        桶的大小,可以在初始化时显示指定
        负载因子，可以在初始化是显示指定

给定的默认容量为16，负载因子是0.75，map使用使用的使用会不断的增加数据，当达到16*0.75就需要
扩容，扩容就需要有数据的复制，就需要消耗性能【尽可能的减少扩容】

Entry是hashMap中的一个内部类，从他的成员变量很容易看出：
    （1）key就是写入时的键
    （2）value就是写入时的值

    开始的时候hashmap有数组和链表组成，所以这个next就用于实现链表结果
    hash存放当前key的hashcode


put操作：首先判断当前的数组是否需要初始化
        如果key  null，返回hash为0，那么就将null存进去
        根据key查找hashcode，根据hashcode定位出所在的桶
        如果桶中是一个链表则需要将桶变量hashcode，key是否和传入key相等
        如果相等，那就将其值返回
        如果是空，说明没有数据存入，新增一个Entry对象写入当前位置。

        当写入的时候，需要判断是否扩容，并将当前的key重新定位

get操作：
        首先也是根据key计算出hashcode，然后定位到桶中
        判断是否为链表
        不是就根据key的hashcode来获取值
        为链表，则需要遍历知道key和hashcode相同的时候
        啥都没有就为null

Java1.8

        1.7中有一个问题，如果hash冲突太多的时候，就会造成链表越来越长，这样查询就会比较慢，时间复杂度也是很高的

        将链表改为了红黑树和阈值，将hashEntry修改为Node
        hshEntry变为了Node

        Node的核心和hashEntry一样，存放的是key value hashcode  next的数据

        put操作之前判断桶是否为null，空的话就需初始化，，根据当前的key的hashcode定位到具体桶中进行判断是否为null
        如果为null，就创建一个桶
        如果有桶，那么就比较桶中的key key的hashcode于写入的key是否相同，如果相同就将值付给e，
        如果当前桶为红黑树，那么需要按照红黑树将数据写入桶中

        如果是链表，就需要将当前的key value封装成一个节点，写入当前桶中

        判断阈值，如果大于阈值，那么就变为红黑数

        如果找到相同的key就直接退出遍历

        如果key中有值，然后将其覆盖掉
        最后判断是否扩容


        get操作
        （1）首先将key hash之后取得锁定位的桶
        （2）如果桶为null,那么就直接返回null
        （3）否则判断桶的第一个位置的key是否为查询的数据key，如果是就返回，如果不是就进行遍历链表
        或者红黑树



存在的问题：容易成为死循环

原因：hashMap扩容的时候会调用resize()方法，这里并发操作易生成一个桶上形成环形链表，计算出index正好是
环形链表的下标就会生成死锁





遍历方法：第一种使用迭代器 使用entrySet进行遍历
        第二种通过获取key的方式进行遍历

        没有做同步操作，会出现问题，甚至死循环


concurrentMap
        由数组和HashEntry组成和hashMap一样
        核心变量：keySet和entrySet
        基本和hashMap一样，唯一区别就是核心数据是略，以及链表都是volidate修饰，保证数据 可见性


        原理上采用分段锁技术，其中segment继承Lock
        