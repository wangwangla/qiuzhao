基本架构：
    pc/app=====>nginx=====》后端服务器=====》消息队列=======》数据库
                            |                       |
                            ===========Redis=========

基本代码流转：
    前端进入web后，就是到达controller层
    之后进行库存效验，下单发往service
    service层在对数据进行持久化，操作完成


无限制：
    正常下单流程
        效验库存
        扣除库存
        创建订单
        支付

假如是简单的单线程访问不会有任何问题，但是高并发时候就会有问题，出现超卖
比如10件商品出现了大于10的订单。




处理方法：
    乐观锁处理，最简单的做法
    在数据库中有一个版本值，每次去数据库中更新数据 的时候，比较这个版本值，如果这个版本值发生了修改，就认为值被修改了，就不会更新数据
    库，如果版本值没哟变就更新这个数据

悲观锁：即使当一个事务锁定了一些数据之后，只有当当前的锁提交了事务，释放了锁，其他事务才可以获得锁并执行操作
使用方法如下：关闭数据库的自动提交
开启事务  执行事务  提交事务
使用select for update开启了悲观锁，锁定一个数据，如果使用了索引就会锁住这一行数据，如果没有使用索引就会将整个表锁住
只有执行了commit，下一个线程才可以拿到正确的数据。

乐观锁：乐观锁，只有在提交修改的时候才会效验，如果冲突了就不会进行更新，每次操作之后都会将版本加1，当下一次操作来的时候，就会
判断是否发生了改变，如果变了更新失败‘



通过吞吐量以及响应效率，web和service都进行了横向的扩展。
web负载均衡     nginx
service使用多个


使用JMeter测试可以直观的看到效果


横向扩展可以提交并发，但是并发更多的时候也会出现问题


解决办法：限流控制




秒杀
    限流  肖峰  异步  缓存
 